<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>任性的雨</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-29T16:47:17.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Leo Ni</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Twisted中遇到的事件驱动框架脏读问题</title>
    <link href="http://yoursite.com/2018/08/09/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E8%84%8F%E8%AF%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/08/09/事件驱动框架脏读问题/</id>
    <published>2018-08-09T05:25:03.000Z</published>
    <updated>2019-01-29T16:47:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="twisted-zhong-yu-dao-de-shi-jian-qu-dong-kuang-jia-zang-du-wen-ti">Twisted中遇到的事件驱动框架脏读问题</span><a href="#twisted-zhong-yu-dao-de-shi-jian-qu-dong-kuang-jia-zang-du-wen-ti" class="header-anchor">#</a></h1><p>在进行Scrapy中间件开发时遇到了全局变量被修改的问题。类比线程有一个线程安全问题， 协程也有协程安全的问题需要考虑。</p><a id="more"></a><h2><span id="wei-shi-me-hui-you-quot-xian-cheng-an-quan-quot-de-wen-ti-chu-xian-ni"><strong>为什么会有<code>&quot;线程安全&quot;</code>的问题出现呢？</strong></span><a href="#wei-shi-me-hui-you-quot-xian-cheng-an-quan-quot-de-wen-ti-chu-xian-ni" class="header-anchor">#</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallel</span><span class="params">(iterable, count, callable, *args, **named)</span>:</span></span><br><span class="line">    <span class="string">"""Execute a callable over the objects in the given iterable, in parallel,</span></span><br><span class="line"><span class="string">    using no more than ``count`` concurrent calls.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Taken from: https://jcalderone.livejournal.com/24285.html</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    coop = task.Cooperator()</span><br><span class="line">    work = (callable(elem, *args, **named) <span class="keyword">for</span> elem <span class="keyword">in</span> iterable)</span><br><span class="line">    <span class="keyword">return</span> defer.DeferredList([coop.coiterate(work) <span class="keyword">for</span> _ <span class="keyword">in</span> range(count)])</span><br></pre></td></tr></table></figure><p>并行函数是通过<code>Cooperator</code>实现的， 这个<code>Cooperator</code>的特点就是，同时添加多个任务， 一个Cooperator有一个定时器<code>Timer</code>来控制执行时间最多为10ms。也就是说，一个包含了100个item的<code>Cooperator</code>，一次理论上执行最多10ms后就得到下一个周期再执行了。</p><p><img src="http://qiniu-blog.cyhlucky.club/2019-01-29-164243.png" alt="image-20190130004026274"></p><p>当这个<code>Cooperator</code>执行10毫秒后， Twisted框架自动跳出这个<code>Cooperator</code>切换到下一个要执行的任务（函数），如果之后的某一个函数修改了公共变量（全局变量或者类变量）， 再切回该<code>Cooperator</code>去访问该公共变量，这时候读到的值就发生了变化。这里的<code>&quot;线程安全&quot;</code>就是<code>脏读</code>现象。</p><h2><span id="zheng-chang-qing-kuang-xia-hui-yu-dao-ma">正常情况下会遇到吗？</span><a href="#zheng-chang-qing-kuang-xia-hui-yu-dao-ma" class="header-anchor">#</a></h2><p>Scrapy使用<code>Cooperator</code>的本意是为了限制item的并发数，防止执行item相关的pipeline耗时过久。</p><p>Scrapy的yield并不能简单地理解为 Python的协程， 而是经过Scrapy自己的一层包装后再递交给Twisted。</p><p><code>Cooperator</code> 非常特殊， Twisted会强制限制执行时间进行切换。</p><p>一般情况下会执行完一个协程后再切换，而<code>Cooperator</code>包了一堆<code>Deferred</code>，以<code>Deferred</code>为单位切换，相当于<strong>限制了一个协程执行的时间， 一个协程执行到一半就切换到了下一个协程去</strong>。</p><p> 理论上像<code>Deferred</code>，<code>Future</code>，<code>Promise</code>都不会遇到这种问题。</p><p>他们并不是直接进行<code>IO</code>切换，而是先加入一个<code>schedule</code>队列再执行完剩余的code。</p><p><strong>Gevent</strong>跟其他的事件驱动框架不同，在遇到<code>IO</code>阻塞的情况下会直接切换协程， 这时候就<strong>容易</strong>出现<code>脏读</code>问题。</p><h3><span id="jie-lun-gevent-hui-yu-dao-ye-bi-jiao-rong-yi-yu-dao-zhe-ge-wen-ti-qi-ta-shi-jian-qu-dong-kuang-jia-ru-guo-ti-gong-liao-qiang-zhi-qie-huan-xie-cheng-de-api-ye-hui-yu-dao-zhe-ge-wen-ti-tong-shi-wo-men-zai-scrapy-kai-fa-zhong-jian-jian-shi-bu-yao-sui-yi-gai-bian-quan-ju-bian-liang-bing-shi-yong-yong-ju-bu-bang-ding-bian-liang-chu-li">结论： <strong>Gevent</strong>会遇到也比较容易遇到这个问题， 其它事件驱动框架如果提供了 <code>强制切换协程的API</code>，也会遇到这个问题。同时我们在Scrapy开发中间件时不要随意改变全局变量并使用，用局部绑定变量处理。</span><a href="#jie-lun-gevent-hui-yu-dao-ye-bi-jiao-rong-yi-yu-dao-zhe-ge-wen-ti-qi-ta-shi-jian-qu-dong-kuang-jia-ru-guo-ti-gong-liao-qiang-zhi-qie-huan-xie-cheng-de-api-ye-hui-yu-dao-zhe-ge-wen-ti-tong-shi-wo-men-zai-scrapy-kai-fa-zhong-jian-jian-shi-bu-yao-sui-yi-gai-bian-quan-ju-bian-liang-bing-shi-yong-yong-ju-bu-bang-ding-bian-liang-chu-li" class="header-anchor">#</a></h3><h2><span id="ben-di-fu-xian-twisted-shi-xian">本地复现（Twisted实现）</span><a href="#ben-di-fu-xian-twisted-shi-xian" class="header-anchor">#</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> defer, reactor, task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.b = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = T()</span><br><span class="line"></span><br><span class="line">t.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(x)</span>:</span></span><br><span class="line">    parallel(get_urls(), <span class="number">100</span>, download)</span><br><span class="line">    print(<span class="string">'tb'</span>, t.b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_urls</span><span class="params">()</span>:</span></span><br><span class="line">    t.b = <span class="number">2</span></span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'url1'</span></span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    t.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_tb</span><span class="params">()</span>:</span></span><br><span class="line">    t.b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="comment"># 类似yield request</span></span><br><span class="line">    request = defer.Deferred()</span><br><span class="line">    <span class="comment"># request.addCallback(lambda x: change_tb())</span></span><br><span class="line">    request.addCallback(<span class="keyword">lambda</span> x: parallel(get_urls(), <span class="number">100</span>, download))</span><br><span class="line">    reactor.callLater(random.random(), request.callback, url)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类似yield item</span></span><br><span class="line">    item = defer.Deferred()</span><br><span class="line">    item.addCallback(_)</span><br><span class="line">    reactor.callLater(<span class="number">0</span>, item.callback, url)</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallel</span><span class="params">(iterable, count, callable, *args, **named)</span>:</span></span><br><span class="line">    coop = task.Cooperator()</span><br><span class="line">    work = (callable(elem, *args, **named) <span class="keyword">for</span> elem <span class="keyword">in</span> iterable)</span><br><span class="line">    <span class="keyword">return</span> defer.DeferredList([coop.coiterate(work) <span class="keyword">for</span> _ <span class="keyword">in</span> range(count)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urls = get_urls()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>):</span><br><span class="line">    finished = parallel(get_urls(), <span class="number">100</span>, download)</span><br><span class="line"></span><br><span class="line">reactor.run()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Twisted中遇到的事件驱动框架脏读问题&quot;&gt;&lt;a href=&quot;#Twisted中遇到的事件驱动框架脏读问题&quot; class=&quot;headerlink&quot; title=&quot;Twisted中遇到的事件驱动框架脏读问题&quot;&gt;&lt;/a&gt;Twisted中遇到的事件驱动框架脏读问题&lt;/h1&gt;&lt;p&gt;在进行Scrapy中间件开发时遇到了全局变量被修改的问题。类比线程有一个线程安全问题， 协程也有协程安全的问题需要考虑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="event-driven" scheme="http://yoursite.com/tags/event-driven/"/>
    
  </entry>
  
  <entry>
    <title>Python编码风格规范</title>
    <link href="http://yoursite.com/2018/07/30/Python%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/07/30/Python编码风格规范/</id>
    <published>2018-07-30T06:54:21.000Z</published>
    <updated>2019-01-29T15:40:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="python-bian-cheng-gui-fan">Python编程规范</span><a href="#python-bian-cheng-gui-fan" class="header-anchor">#</a></h1><div class="toc"><!-- toc --><ul><li><a href="#1-bei-jing">1 背景</a></li><li><a href="#2-yu-yan-gui-fan">2 语言规范</a><ul><li><a href="#2-1-dai-ma-jian-cha-gong-ju">2.1 代码检查工具</a></li><li><a href="#2-2-dao-ru-imports">2.2 导入(Imports)</a></li><li><a href="#2-3-bao-packages">2.3 包(Packages)</a></li><li><a href="#2-4-yi-chang-exceptions">2.4 异常(Exceptions)</a></li><li><a href="#2-5-quan-ju-bian-liang-global-variables">2.5 全局变量(Global variables)</a></li><li><a href="#2-6-qian-tao-ju-bu-nei-bu-lei-he-han-shu-nested-local-inner-classes-and-functions">2.6 嵌套、局部、内部类和函数(Nested/Local/Inner Classes and Functions)</a></li><li><a href="#2-7-tui-dao-shi-he-sheng-cheng-qi-biao-da-shi-comprehensions-generator-expressions">2.7 推导式和生成器表达式(Comprehensions &amp; Generator Expressions)</a></li><li><a href="#2-8-mo-ren-die-dai-qi-he-cao-zuo-fu-default-iterators-and-operators">2.8 默认迭代器和操作符(Default Iterators and Operators)</a></li><li><a href="#2-9-sheng-cheng-qi-generators">2.9 生成器(Generators)</a></li><li><a href="#2-10-ni-ming-han-shu-lambda-functions">2.10 匿名函数(Lambda Functions)</a></li><li><a href="#2-11-tiao-jian-biao-da-shi-conditional-expressions">2.11 条件表达式(Conditional Expressions)</a></li><li><a href="#2-12-mo-ren-can-shu-zhi-default-argument-values">2.12 默认参数值(Default Argument Values)</a></li><li><a href="#2-13-shu-xing-properties">2.13 属性(Properties)</a></li><li><a href="#2-14-true-false-de-qiu-zhi-true-false-evaluations">2.14 True/False的求值(True/False evaluations)</a></li><li><a href="#2-15-guo-shi-de-yu-yan-te-xing-deprecated-language-features">2.15 过时的语言特性(Deprecated Language Features)</a></li><li><a href="#2-16-bian-liang-zuo-yong-yu-lexical-scoping">2.16 变量作用域(Lexical Scoping)</a></li><li><a href="#2-17-han-shu-he-fang-fa-zhuang-shi-qi-function-and-method-decorators">2.17 函数和方法装饰器(Function and Method Decorators)</a></li><li><a href="#2-18-xian-cheng-threading">2.18 线程(Threading)</a></li><li><a href="#2-19-qiang-da-de-te-xing-power-features">2.19 强大的特性(Power Features)</a></li><li><a href="#2-20-xian-dai-hua-python-modern-python-python-3-and-from-future-imports">2.20 现代化Python(Modern Python: Python 3 and from __future__ imports)</a></li><li><a href="#2-21-dai-ma-lei-xing-zhu-shi-type-annotated-code">2.21 代码类型注释(Type Annotated Code)</a></li></ul></li><li><a href="#3-python-feng-ge-gui-fan">3 Python风格规范</a><ul><li><a href="#3-1-dai-ma-ge-shi-hua-gong-ju">3.1 代码格式化工具</a></li><li><a href="#3-2-fen-hao-semicolons">3.2 分号(Semicolons)</a></li><li><a href="#3-3-xing-chang-du-line-length">3.3 行长度(Line length)</a></li><li><a href="#3-4-gua-hao-parentheses">3.4 括号(Parentheses)</a></li><li><a href="#3-5-suo-jin-indentation">3.5 缩进(Indentation)</a></li><li><a href="#3-6-kong-xing-blank-lines">3.6 空行(Blank Lines)</a></li><li><a href="#3-7-kong-ge-whitespace">3.7 空格(Whitespace)</a></li><li><a href="#3-8-shebang-xing-shebang-line">3.8 SheBang行(Shebang Line)</a></li><li><a href="#3-9-zhu-shi-he-wen-dang-zi-fu-chuan-comments-and-docstrings">3.9 注释和文档字符串(Comments and Docstrings)</a></li><li><a href="#3-10-lei-classes">3.10 类(Classes)</a></li><li><a href="#3-11-zi-fu-chuan-strings">3.11 字符串(Strings)</a></li><li><a href="#3-12-wen-jian-he-sockets-files-and-sockets">3.12 文件和sockets(Files and Sockets)</a></li><li><a href="#3-13-todo-zhu-shi-todo-comments">3.13 TODO注释(TODO  Comments)</a></li><li><a href="#3-14-dao-ru-ge-shi-hua-imports-formatting">3.14 导入格式化(Imports formatting)</a></li><li><a href="#3-15-yu-ju-statements">3.15 语句(Statements)</a></li><li><a href="#3-16-fang-wen-kong-zhi-access-control">3.16 访问控制(Access Control)</a></li><li><a href="#3-17-ming-ming-naming">3.17 命名(Naming)</a></li><li><a href="#3-18-zhu-han-shu-main">3.18 主函数(Main)</a></li><li><a href="#3-19-han-shu-chang-du-function-length">3.19 函数长度(Function length)</a></li><li><a href="#3-20-lei-xing-zhu-shi-type-annotations">3.20 类型注释(Type Annotations)</a></li></ul></li><li><a href="#5-lin-bie-zeng-yan">5 临别赠言</a></li></ul><!-- tocstop --></div><h2><span id="1-bei-jing">1 背景</span><a href="#1-bei-jing" class="header-anchor">#</a></h2><p>​        Python是一门动态语言。Python有着非常自由的语法和非常多的特性，开发者可以写出各种充满社会特色主义的代码。本规范的目的不是为了约束开发者的创造力和生产力，而是为了限制开发者的过度个性化，统一团队的代码风格，通过风格一致的代码来更好地进行团队成员之间的协作开发。本规范适用Python3.5以上的版本，部分规范在Python2.7不一定适用。本规范也不推荐开发者继续使用Python2.7开发，Python3会不断地加入新的特性，而Python2.7 到2020年1月1日后将停止被维护。本规范将辅助开发者写出简洁、优雅、高效和风格一致的代码，并且减少踩坑的概率，提升代码的质量，增强开发者的编程规范意识。</p><p>​        本规范主要参照<a href="https://github.com/google/styleguide/blob/gh-pages/pyguide.md" target="_blank" rel="noopener">google code style</a>和 <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP-8</a>完成。</p><a id="more"></a><h2><span id="2-yu-yan-gui-fan">2 语言规范</span><a href="#2-yu-yan-gui-fan" class="header-anchor">#</a></h2><h3><span id="2-1-dai-ma-jian-cha-gong-ju">2.1 代码检查工具</span><a href="#2-1-dai-ma-jian-cha-gong-ju" class="header-anchor">#</a></h3><ul><li>flake8</li><li>IDE自带代码检查工具</li></ul><h4><span id="2-1-1-jie-shi">2.1.1 解释</span><a href="#2-1-1-jie-shi" class="header-anchor">#</a></h4><p>代码检查工具可以找出代码中存在的明显的bug和风格问题。</p><h4><span id="2-1-2-you-dian">2.1.2 优点</span><a href="#2-1-2-you-dian" class="header-anchor">#</a></h4><p>可以找出容易忽略的错误，比如单词拼写错误， 使用了未被赋值的变量等。</p><h4><span id="2-1-3-que-dian">2.1.3 缺点</span><a href="#2-1-3-que-dian" class="header-anchor">#</a></h4><p>代码检查工具不是万能的， 有些warning可能是不对的，在必要的时候可以忽略它们。</p><h4><span id="2-1-4-tui-jian">2.1.4 推荐</span><a href="#2-1-4-tui-jian" class="header-anchor">#</a></h4><p>确保你写的代码经过了代码检查工具的检查，并忽略不必要的warning。</p><h3><span id="2-2-dao-ru-imports">2.2 导入(Imports)</span><a href="#2-2-dao-ru-imports" class="header-anchor">#</a></h3><p>使用<code>import</code>来导入。</p><h4><span id="2-2-1-jie-shi">2.2.1 解释</span><a href="#2-2-1-jie-shi" class="header-anchor">#</a></h4><p>模块间的代码复用。</p><h4><span id="2-2-2-you-dian">2.2.2 优点</span><a href="#2-2-2-you-dian" class="header-anchor">#</a></h4><p>命名空间管理约定简单。<code>x.Obj</code>表示<code>Obj</code>对象在模块<code>x</code>中。</p><h4><span id="2-2-3-que-dian">2.2.3 缺点</span><a href="#2-2-3-que-dian" class="header-anchor">#</a></h4><p>绝对导入在嵌套和命名复杂的情况下， 导入代码会变得非常长。</p><h4><span id="2-2-4-tui-jian">2.2.4 推荐</span><a href="#2-2-4-tui-jian" class="header-anchor">#</a></h4><ul><li><p>使用<code>import x</code>来导入包和模块。</p></li><li><p>使用<code>from x import y</code>当x是包名， y是模块名，模块名最好不要包含前缀。</p></li><li><p>使用<code>from x import y as z</code>,如果y已经被导入了，为了避免重名，重命名为z。</p></li><li><p>使用<code>from x.y import a, b, c</code> x是包名,y是模块名， a,b,c是类，方法或者变量名。</p></li><li><p>使用<code>import y as z</code>，只有业界都这么做的时候才这么做。(比如import numpy as np， 是通用的一个做法)</p></li><li><p>避免方法内的局部导入。(除非遇到循环引用的情况，这个时候需要检查是否必须只能循环引用，能不能拆分代码避免循环引用)</p><p>​</p></li></ul><h3><span id="2-3-bao-packages">2.3 包(Packages)</span><a href="#2-3-bao-packages" class="header-anchor">#</a></h3><p>使用模块的绝对路径名来导入每个模块。</p><h4><span id="2-3-1-jie-shi">2.3.1 解释</span><a href="#2-3-1-jie-shi" class="header-anchor">#</a></h4><p>包是按目录来组织模块的方法。</p><h4><span id="2-3-2-you-dian">2.3.2 优点</span><a href="#2-3-2-you-dian" class="header-anchor">#</a></h4><p>避免模块名冲突，查找模块更加容易。</p><h4><span id="2-3-3-que-dian">2.3.3 缺点</span><a href="#2-3-3-que-dian" class="header-anchor">#</a></h4><p>导入变得困难， 因为必须要带上整个包的路径。</p><h4><span id="2-3-4-tui-jian">2.3.4 推荐</span><a href="#2-3-4-tui-jian" class="header-anchor">#</a></h4><p>使用绝对导入，不推荐使用相对导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reference in code with complete name.</span></span><br><span class="line"><span class="keyword">import</span> absl.flags</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reference in code with just module name (这种方法更好).</span></span><br><span class="line"><span class="keyword">from</span> absl <span class="keyword">import</span> flags</span><br></pre></td></tr></table></figure><h3><span id="2-4-yi-chang-exceptions">2.4 异常(Exceptions)</span><a href="#2-4-yi-chang-exceptions" class="header-anchor">#</a></h3><p>异常需要小心使用。</p><h4><span id="2-4-1-jie-shi">2.4.1 解释</span><a href="#2-4-1-jie-shi" class="header-anchor">#</a></h4><p>异常是一种跳出代码块的正常控制流来处理错误或者其他异常情况的方式。</p><h4><span id="2-4-2-you-dian">2.4.2 优点</span><a href="#2-4-2-you-dian" class="header-anchor">#</a></h4><p>正常操作代码的控制流不会和处理错误的代码混合在一起。当某个特定异常发生的时候，控制流可以跳过。比如，一步跳出N个嵌套的函数，而不用继续执行错误的代码。</p><h4><span id="2-4-3-que-dian">2.4.3 缺点</span><a href="#2-4-3-que-dian" class="header-anchor">#</a></h4><p>控制流可能会让人疑惑。在调用库的时候容易忽略一些错误情况。</p><h4><span id="2-4-4-tui-jian">2.4.4 推荐</span><a href="#2-4-4-tui-jian" class="header-anchor">#</a></h4><ul><li><p>使用<code>raise MyError(&#39;Error message&#39;)</code> 或 <code>raise MyError()</code></p></li><li><p>充分利用内置的异常类。比如，如果你传递了一个负数，但是要求是一个正数，抛出一个<code>ValueError</code>。不要使用<code>assert</code>语句来验证公共API中参数的值。<code>assert</code>被用于确保内部的正确性，而不是为了强制正确的使用，也不是为了表明一些意外的事情发生。如果发生了意外，请使用<code>raise</code>语句。比如，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ConnectToNextPort</span><span class="params">(self, minimum)</span>:</span></span><br><span class="line">    <span class="string">"""Connects to the next available port.  Returns the new minimum port."""</span></span><br><span class="line">    <span class="keyword">if</span> minimum &lt;= <span class="number">1024</span>:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">'Minimum port must be greater than 1024.'</span>)</span><br><span class="line">    port = self._FindNextOpenPort(minimum)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> port:</span><br><span class="line">      <span class="keyword">raise</span> ConnectionError(<span class="string">'Could not connect to service on %d or higher.'</span> % (minimum,))</span><br><span class="line">    <span class="keyword">assert</span> port &gt;= minimum, <span class="string">'Unexpected port %d when minimum was %d.'</span> % (port, minimum)</span><br><span class="line">    <span class="keyword">return</span> port</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ConnectToNextPort</span><span class="params">(self, minimum)</span>:</span></span><br><span class="line">    <span class="string">"""Connects to the next available port.  Returns the new minimum port."""</span></span><br><span class="line">    <span class="keyword">assert</span> minimum &gt; <span class="number">1024</span>, <span class="string">'Minimum port must be greater than 1024.'</span></span><br><span class="line">    port = self._FindNextOpenPort(minimum)</span><br><span class="line">    <span class="keyword">assert</span> port <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> port</span><br></pre></td></tr></table></figure></li><li><p>库和包可以定义它们自己的异常。如果要这么做， 必须继承一个已有的异常类。异常名需要以<code>Error</code>结尾，</p></li><li><p>永远不要使用 <code>except:</code> 语句来捕获所有异常， 该语句将会捕获<code>SystemExit</code> 和<code>KeyboardInterrupt</code>异常，这样会很难通过Control-C中断程序， 并且会掩盖掉其它的异常。如果想要捕捉程序出错的异常，使用<code>except Exception as e:</code>。</p></li><li><p>尽量减少<code>try/except</code>块内的代码量。<code>try</code>的内容越多， 期望外的异常就越容易被触发。在这种情况下<code>try/except</code>块将隐藏真正的错误。</p></li><li><p>使用<code>finally</code>子句。无论有没有异常被抛出，<code>finally</code>子句内的代码都会被执行。对于需要执行清理操作的时候，这是非常有用的。比如，关闭一个文件。</p></li><li><p>当捕获异常时，使用<code>as</code>而不要使用逗号(python3不支持逗号)。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Error</span><br><span class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> error:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul><h3><span id="2-5-quan-ju-bian-liang-global-variables">2.5 全局变量(Global variables)</span><a href="#2-5-quan-ju-bian-liang-global-variables" class="header-anchor">#</a></h3><p>避免全局变量</p><h4><span id="2-5-1-jie-shi">2.5.1 解释</span><a href="#2-5-1-jie-shi" class="header-anchor">#</a></h4><p><code>模块级的变量</code>或<code>类变量</code></p><h4><span id="2-5-2-you-dian">2.5.2 优点</span><a href="#2-5-2-you-dian" class="header-anchor">#</a></h4><p>偶尔有用。</p><h4><span id="2-5-3-que-dian">2.5.3 缺点</span><a href="#2-5-3-que-dian" class="header-anchor">#</a></h4><p>导入时可能会改变模块行为，因为在首次导入模块时会对全局变量赋值。</p><h4><span id="2-5-4-tui-jian">2.5.4 推荐</span><a href="#2-5-4-tui-jian" class="header-anchor">#</a></h4><p>避免使用全局变量。</p><p>例外：</p><ul><li>模块级常量。比如，<code>MAX_HOLY_HANDGRENADE_COUNT = 3</code>。常量单词需要全部大写并且用下划线连接。具体请查看<a href="">命名规范</a>。</li><li>如果需要，全局变量仅在模块内部可用，并在名字前加一个<code>_</code>。外部访问必须通过公共模块级函数来完成。</li></ul><h3><span id="2-6-qian-tao-ju-bu-nei-bu-lei-he-han-shu-nested-local-inner-classes-and-functions">2.6 嵌套、局部、内部类和函数(Nested/Local/Inner Classes and Functions)</span><a href="#2-6-qian-tao-ju-bu-nei-bu-lei-he-han-shu-nested-local-inner-classes-and-functions" class="header-anchor">#</a></h3><p>当嵌套的局部方法或者类是允许的。</p><h4><span id="2-6-1-jie-shi">2.6.1 解释</span><a href="#2-6-1-jie-shi" class="header-anchor">#</a></h4><p>一个类可以在方法、函数或类中被定义。一个函数可以在方法或函数中被定义。嵌套方法拥有对闭包变量<code>只读</code>的权限。</p><h4><span id="2-6-2-you-dian">2.6.2 优点</span><a href="#2-6-2-you-dian" class="header-anchor">#</a></h4><p>允许写一点小的工具类和函数在局部(用于辅助一些操作)，方便直接调用。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">e</span><span class="params">(s)</span>:</span></span><br><span class="line">        sys.stderr.write(<span class="string">'ERROR: '</span>)</span><br><span class="line">        sys.stderr.write(s)</span><br><span class="line">        sys.stderr.write(<span class="string">'\n'</span>)</span><br><span class="line">    e(<span class="string">'I regret to inform you'</span>)</span><br><span class="line">    e(<span class="string">'that a shameful thing has happened.'</span>)</span><br><span class="line">    e(<span class="string">'Thus, I must issue this desultory message'</span>)</span><br><span class="line">    e(<span class="string">'across numerous lines.'</span>)</span><br><span class="line">Foo()</span><br></pre></td></tr></table></figure><h4><span id="2-6-3-que-dian">2.6.3 缺点</span><a href="#2-6-3-que-dian" class="header-anchor">#</a></h4><p>嵌套和局部的类实例不能被序列化(pickled)。嵌套的方法和类不能被直接得测试。嵌套可能会让你的函数更长并减少可读性。</p><h4><span id="2-6-4-tui-jian">2.6.4 推荐</span><a href="#2-6-4-tui-jian" class="header-anchor">#</a></h4><p>推荐使用。</p><h3><span id="2-7-tui-dao-shi-he-sheng-cheng-qi-biao-da-shi-comprehensions-amp-generator-expressions">2.7 推导式和生成器表达式(Comprehensions &amp; Generator Expressions)</span><a href="#2-7-tui-dao-shi-he-sheng-cheng-qi-biao-da-shi-comprehensions-amp-generator-expressions" class="header-anchor">#</a></h3><p>适合在简单情况下使用。</p><h4><span id="2-7-1-jie-shi">2.7.1 解释</span><a href="#2-7-1-jie-shi" class="header-anchor">#</a></h4><p>列表，字典和集合推导式和生成器表达式提供了一种简洁高效的方式来创造容器类和迭代器，而不必借助于传统的循环， <code>map()</code>, <code>filter()</code>, 或者是<code>lambada</code>。</p><h4><span id="2-7-2-you-dian">2.7.2 优点</span><a href="#2-7-2-you-dian" class="header-anchor">#</a></h4><p>简单的推导式比其他<code>dict</code>, <code>list</code>或<code>set</code>的创建方法更加清晰简单。生成器表达式非常高效， 因为它们避免一次性创建整个列表。</p><h4><span id="2-7-3-que-dian">2.7.3 缺点</span><a href="#2-7-3-que-dian" class="header-anchor">#</a></h4><p>复杂的推导式或生成器表达式会导致阅读障碍。</p><h4><span id="2-7-4-tui-jian">2.7.4 推荐</span><a href="#2-7-4-tui-jian" class="header-anchor">#</a></h4><p>适合在简单情况下使用。 每个部分应该单独一行：映射(mapping)表达式， <code>for</code>语句， 过滤表达式。</p><p><strong>禁止</strong>多重<code>for</code>语句或者过滤表达式。在复杂情况下，使用循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">      <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">          <span class="keyword">if</span> x * y &gt; <span class="number">10</span>:</span><br><span class="line">              result.append((x, y))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">      <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">          <span class="keyword">if</span> x != y:</span><br><span class="line">              <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">5</span>):</span><br><span class="line">                  <span class="keyword">if</span> y != z:</span><br><span class="line">                      <span class="keyword">yield</span> (x, y, z)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((x, complicated_transform(x))</span><br><span class="line">          <span class="keyword">for</span> x <span class="keyword">in</span> long_generator_function(parameter)</span><br><span class="line">          <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">  squares = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">  eat(jelly_bean <span class="keyword">for</span> jelly_bean <span class="keyword">in</span> jelly_beans</span><br><span class="line">      <span class="keyword">if</span> jelly_bean.color == <span class="string">'black'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line">  result = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>) <span class="keyword">if</span> x * y &gt; <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((x, y, z)</span><br><span class="line">          <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">5</span>)</span><br><span class="line">          <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5</span>)</span><br><span class="line">          <span class="keyword">if</span> x != y</span><br><span class="line">          <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">5</span>)</span><br><span class="line">          <span class="keyword">if</span> y != z)</span><br></pre></td></tr></table></figure><h3><span id="2-8-mo-ren-die-dai-qi-he-cao-zuo-fu-default-iterators-and-operators">2.8 默认迭代器和操作符(Default Iterators and Operators)</span><a href="#2-8-mo-ren-die-dai-qi-he-cao-zuo-fu-default-iterators-and-operators" class="header-anchor">#</a></h3><p>如果类支持默认的迭代器和操作符，那么就使用它们，比如列表，字典和文件。</p><h4><span id="2-8-1-jie-shi">2.8.1 解释</span><a href="#2-8-1-jie-shi" class="header-anchor">#</a></h4><p>字典和容器类型，比如字典和列表，定义了默认的迭代器和成员关系操作符(<code>in</code>和<code>not in</code>)</p><h4><span id="2-8-2-you-dian">2.8.2 优点</span><a href="#2-8-2-you-dian" class="header-anchor">#</a></h4><p>默认迭代器和操作符简单高效。它们直接调用相关操作，不会因为额外的调用方法而产生开销。使用默认操作符的函数是通用的。任何类都可以去选择实现相关方法来支持这些操作。</p><h4><span id="2-8-3-que-dian">2.8.3 缺点</span><a href="#2-8-3-que-dian" class="header-anchor">#</a></h4><p>类似<code>in</code>和<code>not in</code> 无法直接判断该对象的类型，而如果使用 <code>has_key()</code>则意味着该对象是一个字典。</p><h4><span id="2-8-4-tui-jian">2.8.4 推荐</span><a href="#2-8-4-tui-jian" class="header-anchor">#</a></h4><p>如果默认的类支持默认的迭代器和操作符，比如列表，字典和文件。内建容器类型也定义了迭代器方法。优先考虑这些方法，而不是用另外的返回列表的方法。请注意，在迭代容器的时候，你是不能对它进行修改的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes:  <span class="keyword">for</span> key <span class="keyword">in</span> adict: ...</span><br><span class="line">      <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> adict: ...</span><br><span class="line">      <span class="keyword">if</span> obj <span class="keyword">in</span> alist: ...</span><br><span class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> afile: ...</span><br><span class="line">      <span class="keyword">for</span> k, v <span class="keyword">in</span> dict.iteritems(): ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No:   <span class="keyword">for</span> key <span class="keyword">in</span> adict.keys(): ...</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> adict.has_key(key): ...</span><br><span class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> afile.readlines(): ...</span><br></pre></td></tr></table></figure><h3><span id="2-9-sheng-cheng-qi-generators">2.9 生成器(Generators)</span><a href="#2-9-sheng-cheng-qi-generators" class="header-anchor">#</a></h3><p>按需使用生成器。</p><h4><span id="2-9-1-jie-shi">2.9.1 解释</span><a href="#2-9-1-jie-shi" class="header-anchor">#</a></h4><p>一个生成器函数返回一个迭代器。每当它执行一次yield语句，它就会返回一个值。生成值后，生成器函数的运行状态被挂起直到需要生成下一个值。</p><h4><span id="2-9-2-you-dian">2.9.2 优点</span><a href="#2-9-2-you-dian" class="header-anchor">#</a></h4><p>简化代码， 因为每次调用时，局部变量和控制流的状态都会被保存。生成器仅会占用极少的内存，对于大内存对象的迭代，推荐使用生成器而不是列表。</p><h4><span id="2-9-3-que-dian">2.9.3 缺点</span><a href="#2-9-3-que-dian" class="header-anchor">#</a></h4><p>无。</p><h4><span id="2-9-4-tui-jian">2.9.4 推荐</span><a href="#2-9-4-tui-jian" class="header-anchor">#</a></h4><p>鼓励使用。</p><h3><span id="2-10-ni-ming-han-shu-lambda-functions">2.10 匿名函数(Lambda Functions)</span><a href="#2-10-ni-ming-han-shu-lambda-functions" class="header-anchor">#</a></h3><p>适用于一行的表达式。</p><h4><span id="2-10-1-jie-shi">2.10.1 解释</span><a href="#2-10-1-jie-shi" class="header-anchor">#</a></h4><p><code>Lambda</code>定义了以一个表达式作为匿名函数，经常用于回调和高阶函数比如<code>map()</code>，<code>filter()</code>。</p><h4><span id="2-10-2-you-dian">2.10.2 优点</span><a href="#2-10-2-you-dian" class="header-anchor">#</a></h4><p>方便。</p><h4><span id="2-10-3-que-dian">2.10.3 缺点</span><a href="#2-10-3-que-dian" class="header-anchor">#</a></h4><p>比本地函数更难阅读和调试。没有函数名意味着调用栈跟踪更加难以理解。由于python的lambda函数只能包含一个表达式，因此它的作用有限。</p><h4><span id="2-10-4-tui-jian">2.10.4 推荐</span><a href="#2-10-4-tui-jian" class="header-anchor">#</a></h4><p>对于简单的表达式，可以直接使用匿名函数而不用再单独写一个函数。如果匿名函数代码超过60-80个字符，最好还是定义成单独的函数。对于常见的操作符，比如乘法，使用<code>operator</code>模块中的函数代替<code>lambda</code>函数。比如， 推荐使用<code>operator.mul</code>， 而不是<code>lambda x,y: x*y</code>。</p><h3><span id="2-11-tiao-jian-biao-da-shi-conditional-expressions">2.11 条件表达式(Conditional Expressions)</span><a href="#2-11-tiao-jian-biao-da-shi-conditional-expressions" class="header-anchor">#</a></h3><h4><span id="2-11-1-jie-shi">2.11.1 解释</span><a href="#2-11-1-jie-shi" class="header-anchor">#</a></h4><p>条件表达式(又被称为三元运算符)提供了比 <code>if</code>语句更短的语法。比如<code>x = 1 if cond else 2</code>。</p><h4><span id="2-11-2-you-dian">2.11.2 优点</span><a href="#2-11-2-you-dian" class="header-anchor">#</a></h4><p>比if语句更加简短和方便。</p><h4><span id="2-11-3-que-dian">2.11.3 缺点</span><a href="#2-11-3-que-dian" class="header-anchor">#</a></h4><p>比if语句读起来累，特别是一个表达式很长的时候。</p><h4><span id="2-11-4-tui-jian">2.11.4 推荐</span><a href="#2-11-4-tui-jian" class="header-anchor">#</a></h4><p>适用于简单的，一行能解决的情况。在需要多行语句才能解决的情况，推荐使用完整的if语句。</p><h3><span id="2-12-mo-ren-can-shu-zhi-default-argument-values">2.12 默认参数值(Default Argument Values)</span><a href="#2-12-mo-ren-can-shu-zhi-default-argument-values" class="header-anchor">#</a></h3><p>适用于大部分情况。</p><h4><span id="2-12-1-jie-shi">2.12.1 解释</span><a href="#2-12-1-jie-shi" class="header-anchor">#</a></h4><p>函数的参数可以指定默认值。如<code>def foo(a, b=0):</code>。如果<code>foo</code>只传入一个参数，那么b的值就是0。如果传入两个参数，b的值就是第二个参数的值。</p><h4><span id="2-12-2-you-dian">2.12.2 优点</span><a href="#2-12-2-you-dian" class="header-anchor">#</a></h4><p>你经常会碰到一些使用大量默认值的函数， 但偶尔(比较少见)你想要覆盖这些默认值。默认参数值提供了一种简单的方法来完成这件事， 你不需要为这些罕见的例外定义大量函数。同时, Python也不支持重载方法和函数，默认参数是一种”仿造”重载行为的简单方式。</p><h4><span id="2-12-3-que-dian">2.12.3 缺点</span><a href="#2-12-3-que-dian" class="header-anchor">#</a></h4><p>默认参数只在模块加载时求值一次，如果参数是列表或字典之类的可变类型, 这可能会导致问题。如果在函数内部对该可变对象进行修改(比如向列表追加项<code>l.append(&#39;sth&#39;)</code>)，默认参数的值就被修改了。</p><h4><span id="2-12-4-tui-jian">2.12.4 推荐</span><a href="#2-12-4-tui-jian" class="header-anchor">#</a></h4><p>鼓励使用。不过有如下注意事项：</p><p>不要在函数或方法定义中使用可变对象作为默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=None)</span>:</span></span><br><span class="line">         <span class="keyword">if</span> b <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">             b = []</span><br><span class="line">Yes: <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b: Optional[Sequence] = None)</span>:</span></span><br><span class="line">         <span class="keyword">if</span> b <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">             b = []</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=[])</span>:</span></span><br><span class="line">         ...</span><br><span class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=time.time<span class="params">()</span>)</span>:</span>  <span class="comment"># The time the module was loaded???</span></span><br><span class="line">         ...</span><br><span class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b=FLAGS.my_thing)</span>:</span>  <span class="comment"># sys.argv has not yet been parsed...</span></span><br><span class="line">         ...</span><br></pre></td></tr></table></figure><h3><span id="2-13-shu-xing-properties">2.13 属性(Properties)</span><a href="#2-13-shu-xing-properties" class="header-anchor">#</a></h3><p>访问和设置数据成员时， 你通常会使用简单，轻量级的访问和设置函数。建议用属性(properties)来代替它们。</p><h4><span id="2-13-1-jie-shi">2.13.1 解释</span><a href="#2-13-1-jie-shi" class="header-anchor">#</a></h4><p>能够包装getter和setter。 当运算量不大, 它是获取和设置属性(attribute)的标准方式.</p><h4><span id="2-13-2-you-dian">2.13.2 优点</span><a href="#2-13-2-you-dian" class="header-anchor">#</a></h4><p>指定显式的属性get和set方法可以提高可读性。允许延迟计算(lazy calculation)。不需要对类的接口进行改动。</p><h4><span id="2-13-3-que-dian">2.13.3 缺点</span><a href="#2-13-3-que-dian" class="header-anchor">#</a></h4><p>在实例属性需要频繁访问的时候， 通过直接访问属性的速度会是通过该方式访问属性的3倍。在高性能编程下需要注意<code>@property</code>可能带来的性能问题。</p><h4><span id="2-13-4-tui-jian">2.13.4 推荐</span><a href="#2-13-4-tui-jian" class="header-anchor">#</a></h4><p>推荐使用<code>@property</code>装饰器的方式来获取或者设置属性，在获取属性需要通过简单的计算表达式得出结果时，这是非常适合的。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.pi * self.radius**<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Yes: </span><br><span class="line">     <span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(object)</span>:</span></span><br><span class="line">         <span class="string">"""A square with two properties: a writable area and a read-only perimeter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         To use:</span></span><br><span class="line"><span class="string">         &gt;&gt;&gt; sq = Square(3)</span></span><br><span class="line"><span class="string">         &gt;&gt;&gt; sq.area</span></span><br><span class="line"><span class="string">         9</span></span><br><span class="line"><span class="string">         &gt;&gt;&gt; sq.perimeter</span></span><br><span class="line"><span class="string">         12</span></span><br><span class="line"><span class="string">         &gt;&gt;&gt; sq.area = 16</span></span><br><span class="line"><span class="string">         &gt;&gt;&gt; sq.side</span></span><br><span class="line"><span class="string">         4</span></span><br><span class="line"><span class="string">         &gt;&gt;&gt; sq.perimeter</span></span><br><span class="line"><span class="string">         16</span></span><br><span class="line"><span class="string">         """</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, side)</span>:</span></span><br><span class="line">             self.side = side</span><br><span class="line"></span><br><span class="line"><span class="meta">         @property</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">             <span class="string">"""Gets or sets the area of the square."""</span></span><br><span class="line">             <span class="keyword">return</span> self._get_area()</span><br><span class="line"></span><br><span class="line"><span class="meta">         @area.setter</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self, area)</span>:</span></span><br><span class="line">             <span class="keyword">return</span> self._set_area(area)</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">_get_area</span><span class="params">(self)</span>:</span></span><br><span class="line">             <span class="string">"""Indirect accessor to calculate the 'area' property."""</span></span><br><span class="line">             <span class="keyword">return</span> self.side ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">_set_area</span><span class="params">(self, area)</span>:</span></span><br><span class="line">             <span class="string">"""Indirect setter to set the 'area' property."""</span></span><br><span class="line">             self.side = math.sqrt(area)</span><br><span class="line"></span><br><span class="line"><span class="meta">         @property</span></span><br><span class="line">         <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span><span class="params">(self)</span>:</span></span><br><span class="line">             <span class="keyword">return</span> self.side * <span class="number">4</span></span><br></pre></td></tr></table></figure><p>避免太过简单的包装。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line"><span class="meta">     @property</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">     <span class="string">"""Gets or sets the area of the square."""</span></span><br><span class="line">         <span class="keyword">return</span> self._area</span><br></pre></td></tr></table></figure><p>避免通过<code>property</code>的方式设置getter和setter。使用<code>@property</code>和<a href="mailto:`@sth.setter" target="_blank" rel="noopener">`@sth.setter</a>`。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line">area = property(___get_area, ___set_area,</span><br><span class="line">                         doc=<span class="string">"""Gets or sets the area of the square."""</span>)</span><br></pre></td></tr></table></figure><h3><span id="2-14-true-false-de-qiu-zhi-true-false-evaluations">2.14 True/False的求值(True/False evaluations)</span><a href="#2-14-true-false-de-qiu-zhi-true-false-evaluations" class="header-anchor">#</a></h3><p>尽可能使用隐式false</p><h4><span id="2-14-1-jie-shi">2.14.1 解释</span><a href="#2-14-1-jie-shi" class="header-anchor">#</a></h4><p>Python在布尔上下文中会将某些值求值为<code>False</code>。 按简单的直觉来讲， 就是所有的”空”值都被认为是false。因此 <code>0, None, [], {}, &quot;&quot;</code>都被认为是false值。</p><h4><span id="2-14-2-you-dian">2.14.2 优点</span><a href="#2-14-2-you-dian" class="header-anchor">#</a></h4><p>使用Pythonic布尔值的条件语句更易读也更不易犯错。</p><h4><span id="2-14-3-que-dian">2.14.3 缺点</span><a href="#2-14-3-que-dian" class="header-anchor">#</a></h4><p>对于C/C++等其它语言开发人员来说，会感觉有点奇怪。</p><h4><span id="2-14-4-tui-jian">2.14.4 推荐</span><a href="#2-14-4-tui-jian" class="header-anchor">#</a></h4><p>尽可能使用隐式的false， 例如: 使用 <code>if foo:</code> 而不是 <code>if foo != []:</code> . 不过还是有一些注意事项需要你铭记在心:</p><ul><li>永远不要用==或者!=来比较某些单例， 比如None。 使用<code>is</code>或者is not。</li><li>注意: 当你写下 <code>if x:</code> 时， 如果你其实表示的是 <code>if x is not None</code>，那么<code>if x:</code>是不对的。 例如: 当你要测试一个默认值是None的变量或参数是否被设为其它值。 这个值在布尔语义下可能是false！</li><li>永远不要用==将一个布尔量与false相比较. 使用 <code>if not x:</code> 代替. 如果你需要区分false和None, 你应该用像 <code>if not x and x is not None:</code> 这样的语句。</li><li>对于序列(字符串, 列表, 元组), 要注意空序列是false。因此 <code>if not seq:</code> 或者 <code>if seq:</code> 比 <code>if len(seq):</code> 或 <code>if not len(seq):</code> 要更好。</li><li>处理整数时, 使用隐式false可能会得不偿失(即不小心将None当做0来处理). 你可以将一个已知是整型(且不是len()的返回结果)的值与0比较。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> <span class="keyword">not</span> users:</span><br><span class="line">         print(<span class="string">'no users'</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> foo == <span class="number">0</span>:</span><br><span class="line">         self.handle_zero()</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">         self.handle_multiple_of_ten()</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x=None)</span>:</span></span><br><span class="line">         <span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">             x = []</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">No:  <span class="keyword">if</span> len(users) == <span class="number">0</span>:</span><br><span class="line">         print(<span class="string">'no users'</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> foo <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> foo:</span><br><span class="line">         self.handle_zero()</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> i % <span class="number">10</span>:</span><br><span class="line">         self.handle_multiple_of_ten()</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x=None)</span>:</span></span><br><span class="line">         x = x <span class="keyword">or</span> []</span><br></pre></td></tr></table></figure><ul><li><p>注意’0’(字符串)会被当做true。</p><p>​</p></li></ul><h3><span id="2-15-guo-shi-de-yu-yan-te-xing-deprecated-language-features">2.15 过时的语言特性(Deprecated Language Features)</span><a href="#2-15-guo-shi-de-yu-yan-te-xing-deprecated-language-features" class="header-anchor">#</a></h3><p>使用字符串方法代替字符串模块。使用列表推导式和<code>for</code>循环代替<code>filter</code>。在<code>map</code> 中少用复杂的lambda函数。使用<code>for</code>循环而不是<code>reduce</code>。</p><h4><span id="2-15-1-jie-shi">2.15.1 解释</span><a href="#2-15-1-jie-shi" class="header-anchor">#</a></h4><p>当前版本的Python提供了大家更喜欢的特性。</p><h4><span id="2-15-2-tui-jian">2.15.2 推荐</span><a href="#2-15-2-tui-jian" class="header-anchor">#</a></h4><p>我们不使用陈旧的Python版本，而是尽可能使用新的和稳定的Python版本。所以我们应该尝试、习惯并探索更好的特性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Yes: words = foo.split(<span class="string">':'</span>)</span><br><span class="line"></span><br><span class="line">     [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> my_list <span class="keyword">if</span> x[<span class="number">2</span>] == <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">     map(math.sqrt, data)    <span class="comment"># Ok. No inlined lambda expression.</span></span><br><span class="line"></span><br><span class="line">     fn(*args, **kwargs)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">No:  words = string.split(foo, <span class="string">':'</span>)</span><br><span class="line"></span><br><span class="line">     map(<span class="keyword">lambda</span> x: x[<span class="number">1</span>], filter(<span class="keyword">lambda</span> x: x[<span class="number">2</span>] == <span class="number">5</span>, my_list))</span><br><span class="line"></span><br><span class="line">     apply(fn, args, kwargs)</span><br></pre></td></tr></table></figure><h3><span id="2-16-bian-liang-zuo-yong-yu-lexical-scoping">2.16 变量作用域(Lexical Scoping)</span><a href="#2-16-bian-liang-zuo-yong-yu-lexical-scoping" class="header-anchor">#</a></h3><p>不要使用会让人误解的局部变量和全局变量，不同的变量作用域不同。</p><h4><span id="2-16-1-jie-shi">2.16.1 解释</span><a href="#2-16-1-jie-shi" class="header-anchor">#</a></h4><p>嵌套的Python函数可以引用外层函数中定义的变量，但是不能够对它们赋值。变量绑定的解析是使用词法作用域, 也就是基于静态的程序文本。对一个块中的某个名称的任何赋值都会导致Python将对该名称的全部引用当做局部变量， 甚至是赋值前的处理。 如果碰到global声明，该变量就会被视作全局变量。</p><p>一个使用闭包的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_adder</span><span class="params">(summand1)</span>:</span></span><br><span class="line">    <span class="string">"""Returns a function that adds numbers to a given number."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adder</span><span class="params">(summand2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> summand1 + summand2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adder</span><br></pre></td></tr></table></figure><p>调用方式<code>sum = get_adder(summand1)(summand2)</code></p><h4><span id="2-16-2-you-dian">2.16.2 优点</span><a href="#2-16-2-you-dian" class="header-anchor">#</a></h4><p>结果更加清晰，对Lisp和Scheme(Haskell，ML等)程序员友好</p><h4><span id="2-16-3-que-dian">2.16.3 缺点</span><a href="#2-16-3-que-dian" class="header-anchor">#</a></h4><p>可能会产生令人费解的bug。</p><p>例如这个依据 <a href="http://www.python.org/dev/peps/pep-0227/" target="_blank" rel="noopener">PEP 0227</a> 的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        print(i, end=<span class="string">''</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># A bunch of code here</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:  <span class="comment"># Ah, i *is* local to foo, so this is what bar sees</span></span><br><span class="line">        print(i, end=<span class="string">''</span>)</span><br><span class="line">    bar()</span><br></pre></td></tr></table></figure><p>因此 <code>foo([1, 2, 3])</code> 会打印 <code>1 2 3 3</code> ，不是 <code>1 2 3 4</code> 。</p><p>因为foo函数中的i被隐式赋值为3， 而不是使用全局的4。</p><h4><span id="2-16-4-tui-jian">2.16.4 推荐</span><a href="#2-16-4-tui-jian" class="header-anchor">#</a></h4><p><strong>非常熟悉该特性的开发者可以使用。否则慎用。</strong></p><p>闭包会有一些问题比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure><p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1</code>，<code>4</code>，<code>9</code>，但实际结果是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>解释：返回函数引用变量<code>i</code>，但是它并不是立即执行的，而是延迟执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>3</code>，因此最终结果为<code>9</code>。</p><p>如果一定要引用循环变量怎么办？方法是再创建一个函数立即执行，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> j*j</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        fs.append(f(i)) <span class="comment"># f(i)立刻被执行，因此i的当前值被传入f()</span></span><br><span class="line">    <span class="keyword">return</span> fs</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1, f2, f3 = count()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p><code>返回闭包时牢记：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</code></p><h3><span id="2-17-han-shu-he-fang-fa-zhuang-shi-qi-function-and-method-decorators">2.17 函数和方法装饰器(Function and Method Decorators)</span><a href="#2-17-han-shu-he-fang-fa-zhuang-shi-qi-function-and-method-decorators" class="header-anchor">#</a></h3><p>使用装饰器。避免使用<code>@staticmethod</code>以及限制使用<code>@classmethod</code></p><h4><span id="2-17-1-jie-shi">2.17.1 解释</span><a href="#2-17-1-jie-shi" class="header-anchor">#</a></h4><p><a href="https://docs.python.org/release/2.4.3/whatsnew/node6.html" target="_blank" rel="noopener">用于函数及方法的装饰器</a> (也就是@标记)。一个流行的装饰器是<code>@property</code>用于把普通的方法转化成属性。装饰器也允许由用户自定义。比如<code>my_decorator</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">    @my_decorator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># method body ...</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C:</span><br><span class="line">    def Methodmethod(self):</span><br><span class="line">        # method body ...</span><br><span class="line">    Methodmethod = MyDecoratormy_decorator(Methodmethod)</span><br></pre></td></tr></table></figure><h4><span id="2-17-2-you-dian">2.17.2 优点</span><a href="#2-17-2-you-dian" class="header-anchor">#</a></h4><p>优雅地定义了，减少重复的代码，从纵向上减少代码的耦合程度。具有面向切面编程的优点。</p><h4><span id="2-17-3-que-dian">2.17.3 缺点</span><a href="#2-17-3-que-dian" class="header-anchor">#</a></h4><p>装饰器会修改函数的参数或者返回值，这些操作都是隐式的。另外装饰器在导入时(import time)与函数绑定生效。装饰器中产生的错误会更加难追查。</p><h4><span id="2-17-4-tui-jian">2.17.4 推荐</span><a href="#2-17-4-tui-jian" class="header-anchor">#</a></h4><p>如果有非常明显的优点(代码复用，面向切面编程)，那么就可以使用它。装饰器需要遵守和函数一样的导入和命名规则。装饰器的文档需要说明这是一个装饰器。为装饰器编写健壮的单元测试。</p><p>避免装饰器对外部的依赖(比如不要依赖文件，socket，数据库连接等)。要保证装饰器的有效调用在任何情况下都是成功的。</p><p>装饰器是一种特殊的“顶层代码”(top level code)。</p><p>少用<code>@staticmethod</code>。大多数情况下，直接使用模块级的函数更加适合而不是跟类耦合在一起。少部分情况下，在函数只被该类使用的情况下，可以使用<code>@staticmethod</code>。</p><p>仅在写构造函数时使用<code>@classmethod</code>。如果要修改类变量的值，也需要使用<code>@classmethod</code>。</p><h3><span id="2-18-xian-cheng-threading">2.18 线程(Threading)</span><a href="#2-18-xian-cheng-threading" class="header-anchor">#</a></h3><p>不要依赖内建类型(<code>built-in</code>)的原子性。</p><h4><span id="2-18-1-tui-jian">2.18.1 推荐</span><a href="#2-18-1-tui-jian" class="header-anchor">#</a></h4><p>虽然Python的内建类型比如字典的操作看上去都是原子的，但是在某些情况下它们仍然不是原子的(如果<code>__hash__</code>或<code>__eq__</code>以Python代码实现)，因此他们的原子性是不可靠的。</p><p>使用<code>Queue</code>作为线程间的数据通信方式。其它情况，使用<code>threading</code>模块和锁原语(locking primitives)。学习<code>condition</code>的适用场景，你可以使用<code>threading.Condition</code>来取代低级别的<code>Lock</code>。</p><h3><span id="2-19-qiang-da-de-te-xing-power-features">2.19 强大的特性(Power Features)</span><a href="#2-19-qiang-da-de-te-xing-power-features" class="header-anchor">#</a></h3><p>强大不等于好用， 相反强大的特性正式因为它能做的事情过于强大，容易让初中级程序员翻船。</p><h4><span id="2-19-1-jie-shi">2.19.1 解释</span><a href="#2-19-1-jie-shi" class="header-anchor">#</a></h4><p>Python是非常灵活的语言， 它为你提供了很多花哨的特性，诸如元类(metaclasses)，字节码(bytecode)访问, 任意编译(on-the-fly compilation)，动态继承(dynamic inheritance)，对象父类重定义(object reparenting)，导入黑客(import hacks), 反射，系统内修改(modification of system internals)等等。</p><h4><span id="2-19-2-you-dian">2.19.2 优点</span><a href="#2-19-2-you-dian" class="header-anchor">#</a></h4><p>强大的语言特性，可以让你的代码更加简洁紧凑。</p><h4><span id="2-19-3-que-dian">2.19.3 缺点</span><a href="#2-19-3-que-dian" class="header-anchor">#</a></h4><p>奇淫技巧的代码会变得难以阅读和调试。刚开始写下这些代码时还能理解，但是当后续回顾这些代码时，理解起来还不如一些虽然写得比较长还是表达意思很直接的代码。</p><h4><span id="2-19-4-tui-jian">2.19.4 推荐</span><a href="#2-19-4-tui-jian" class="header-anchor">#</a></h4><p>除非你对你将要使用的特性理解非常深入(你能够理解为什么要这么做，以及懂得怎么正确地去做)， 否则不要使用这些奇淫技巧。</p><p>有些特性经过封装后，我们认为它是相对安全并且容易理解的。</p><p>部分使用了这些特性的标准库的模块和类是允许使用的(比如<code>abc.ABCMeta</code>，<code>collections.namedtuple</code>和<code>enum</code>)。</p><h3><span id="2-20-xian-dai-hua-python-modern-python-python-3-and-from-future-imports">2.20 现代化Python(Modern Python: Python 3 and from __future__ imports)</span><a href="#2-20-xian-dai-hua-python-modern-python-python-3-and-from-future-imports" class="header-anchor">#</a></h3><p>Python3即将开启新的时代！ 但是某些项目还不支持Python3， 因此那些项目需要进行迁移或是兼容。</p><h4><span id="2-20-1-jie-shi">2.20.1 解释</span><a href="#2-20-1-jie-shi" class="header-anchor">#</a></h4><p>Python3是Python的一个重要的改变。但是Python2的代码仍然存在，这时候需要利用future模块来进行兼容，而不需要做太大的改动。</p><h4><span id="2-20-2-you-dian">2.20.2 优点</span><a href="#2-20-2-you-dian" class="header-anchor">#</a></h4><p>Python3的语法更加优雅。</p><h4><span id="2-20-3-que-dian">2.20.3 缺点</span><a href="#2-20-3-que-dian" class="header-anchor">#</a></h4><p>future模块可能有些丑。没错，毕竟future是为了兼容所做的妥协。</p><h4><span id="2-20-4-tui-jian">2.20.4 推荐</span><a href="#2-20-4-tui-jian" class="header-anchor">#</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br></pre></td></tr></table></figure><p>如果你对这些兼容为什么要这么做不太了解，你可以阅读 <a href="https://www.python.org/dev/peps/pep-0328/" target="_blank" rel="noopener">absolute imports</a>, <a href="https://www.python.org/dev/peps/pep-0238/" target="_blank" rel="noopener">new <code>/</code> division behavior</a>, and <a href="https://www.python.org/dev/peps/pep-3105/" target="_blank" rel="noopener">the print function</a>。</p><p>future, six模块可以帮助你进行Python2和3的兼容。</p><p>如果没有兼容Python2的必要，请选择Python3.5+的版本进行编程。</p><p>仔细阅读<a href="https://docs.python.org/3/howto/pyporting.html" target="_blank" rel="noopener">Python2到3迁移</a>，并对自己的项目进行改造。😄</p><p>在100%的情况下不建议再使用Python2进行编程。</p><h3><span id="2-21-dai-ma-lei-xing-zhu-shi-type-annotated-code">2.21 代码类型注释(Type Annotated Code)</span><a href="#2-21-dai-ma-lei-xing-zhu-shi-type-annotated-code" class="header-anchor">#</a></h3><p>非常好的特性， 你可以对Python3.5+的代码进行注释，参考 <a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener">PEP-484</a>。从python3.6开始还增加了变量注释，参考<a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="noopener">PEP-0526</a>。</p><h4><span id="2-21-1-jie-shi">2.21.1 解释</span><a href="#2-21-1-jie-shi" class="header-anchor">#</a></h4><p>类型注释<code>type annotations</code>(或者说类型提示<code>type hints</code>)是对函数参数和返回值进行注释。</p><p>类型注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: int)</span> -&gt; List[int]:</span></span><br></pre></td></tr></table></figure><p>变量注释：</p><p><code>some_number: int</code></p><p><code>valuesome_list: List[int] = []</code></p><h4><span id="2-21-2-you-dian">2.21.2 优点</span><a href="#2-21-2-you-dian" class="header-anchor">#</a></h4><p>类型注释提高了你代码的可读性和可维护性。类型检查器可以根据类型注释把可能在运行时发生的错误提前检查出来。提高了项目的工程强度。</p><h4><span id="2-21-3-que-dian">2.21.3 缺点</span><a href="#2-21-3-que-dian" class="header-anchor">#</a></h4><ul><li>Python3.5+支持。你需要不停更新这些类型声明。但是这会让你对你的代码非常熟悉，其实也算是一个优点。</li><li>可能会限制开发者使用一些Python奇淫技巧的能力。</li></ul><h4><span id="2-21-4-tui-jian">2.21.4 推荐</span><a href="#2-21-4-tui-jian" class="header-anchor">#</a></h4><p>如果你的项目复杂到你必须进行类型注释，那么这一定是一个值得一试的特性。</p><p>把代码变成类似静态语言的风格并不是在开倒车，在一个大型项目下这是必须要做的事情。</p><h2><span id="3-python-feng-ge-gui-fan">3 Python风格规范</span><a href="#3-python-feng-ge-gui-fan" class="header-anchor">#</a></h2><h3><span id="3-1-dai-ma-ge-shi-hua-gong-ju">3.1 代码格式化工具</span><a href="#3-1-dai-ma-ge-shi-hua-gong-ju" class="header-anchor">#</a></h3><p>使用代码格式化插件格式化代码。</p><p><strong>Pycharm</strong></p><p>使用Cmd + Option + L（Windows：Control+Alt+L）快捷键进行格式化。</p><p><strong>Visual Studio Code</strong></p><p>通过pip安装flake8和yapf<br>安装VSCode的Python扩展<br>使用Option+Shift+F（Windows：Alt+Shift+F）</p><h3><span id="3-2-fen-hao-semicolons">3.2 分号(Semicolons)</span><a href="#3-2-fen-hao-semicolons" class="header-anchor">#</a></h3><p>不要在行尾添加分号，也不要用分号将两条命令放在同一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="keyword">import</span> b</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line"><span class="keyword">import</span> a;<span class="keyword">import</span> b;</span><br></pre></td></tr></table></figure><h3><span id="3-3-xing-chang-du-line-length">3.3 行长度(Line length)</span><a href="#3-3-xing-chang-du-line-length" class="header-anchor">#</a></h3><p>每行不超过120个字符。</p><p>例外：</p><ul><li>很长的导入语句。</li><li>URL，路径名，或者注释中非常长的flag。</li></ul><p>不要使用反斜杠换行。</p><p>Python会把<code>(),[],{}</code>中的行自动隐式地连接到一起， 可以利用这个特性连接行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes: foo_bar(self, width, height, color=<span class="string">'black'</span>, design=<span class="keyword">None</span>, x=<span class="string">'foo'</span>,</span><br><span class="line">             emphasis=<span class="keyword">None</span>, highlight=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">         color == <span class="string">'red'</span> <span class="keyword">and</span> emphasis == <span class="string">'strong'</span>):</span><br></pre></td></tr></table></figure><p>如果一个字符串在一行放不下， 使用圆括号来进行隐式的连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="string">'This will build a very long long '</span></span><br><span class="line">     <span class="string">'long long long long long long string'</span>)</span><br></pre></td></tr></table></figure><p>在注释中，可以把长的URL放在一行上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes:  <span class="comment"># See details at</span></span><br><span class="line">      <span class="comment"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No:  # See details at</span><br><span class="line">     # http://www.example.com/us/developer/documentation/api/content/\</span><br><span class="line">     # v2.0/csv_file_name_extension_full_specification.html</span><br></pre></td></tr></table></figure><p>在使用<code>with</code>语句时， 三个以上的表达式可以被反斜杠分为多行。对于两行表达式，使用嵌套<code>with</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes:  <span class="keyword">with</span> very_long_first_expression_function() <span class="keyword">as</span> spam, \</span><br><span class="line">           very_long_second_expression_function() <span class="keyword">as</span> beans, \</span><br><span class="line">           third_thing() <span class="keyword">as</span> eggs:</span><br><span class="line">          place_order(eggs, beans, spam, beans)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No:  <span class="keyword">with</span> VeryLongFirstExpressionFunction() <span class="keyword">as</span> spam, \</span><br><span class="line">          VeryLongSecondExpressionFunction() <span class="keyword">as</span> beans:</span><br><span class="line">       PlaceOrder(eggs, beans, spam, beans)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes:  <span class="keyword">with</span> very_long_first_expression_function() <span class="keyword">as</span> spam:</span><br><span class="line">          <span class="keyword">with</span> very_long_second_expression_function() <span class="keyword">as</span> beans:</span><br><span class="line">              place_order(beans, spam)</span><br></pre></td></tr></table></figure><h3><span id="3-4-gua-hao-parentheses">3.4 括号(Parentheses)</span><a href="#3-4-gua-hao-parentheses" class="header-anchor">#</a></h3><p>少用括号。</p><p>除非是为了实现行与行之间的连接，否则不要在返回语句或条件语句中使用括号。在元祖两边使用括号是必要的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> foo:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">while</span> x:</span><br><span class="line">         x = bar()</span><br><span class="line">     <span class="keyword">if</span> x <span class="keyword">and</span> y:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">         bar()</span><br><span class="line">     <span class="comment"># 对于只包含一项的元祖，比起onesie = foo来说, 加上括号更加明显</span></span><br><span class="line">     onesie = (foo,)</span><br><span class="line">     <span class="keyword">return</span> foo</span><br><span class="line">     <span class="keyword">return</span> spam, beans</span><br><span class="line">     <span class="keyword">return</span> (spam, beans)</span><br><span class="line">     <span class="keyword">for</span> (x, y) <span class="keyword">in</span> dict.items(): ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">No:  <span class="keyword">if</span> (x):</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span>(x):</span><br><span class="line">         bar()</span><br><span class="line">     <span class="keyword">return</span> (foo)</span><br></pre></td></tr></table></figure><h3><span id="3-5-suo-jin-indentation">3.5 缩进(Indentation)</span><a href="#3-5-suo-jin-indentation" class="header-anchor">#</a></h3><p>使用4个空格缩进代码。</p><p>不要使用tab！对于行链接的情况，使用垂直对齐：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Yes:   <span class="comment"># Aligned with opening delimiter</span></span><br><span class="line">       foo = long_function_name(var_one, var_two,</span><br><span class="line">                                var_three, var_four)</span><br><span class="line">       meal = (spam,</span><br><span class="line">               beans)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># Aligned with opening delimiter in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key: value1 +</span><br><span class="line">                                value2,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent; nothing on first line</span></span><br><span class="line">       foo = long_function_name(</span><br><span class="line">           var_one, var_two, var_three,</span><br><span class="line">           var_four)</span><br><span class="line">       meal = (</span><br><span class="line">           spam,</span><br><span class="line">           beans)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key:</span><br><span class="line">               long_dictionary_value,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">No:    <span class="comment"># Stuff on first line forbidden</span></span><br><span class="line">       foo = long_function_name(var_one, var_two,</span><br><span class="line">           var_three, var_four)</span><br><span class="line">       meal = (spam,</span><br><span class="line">           beans)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 2-space hanging indent forbidden</span></span><br><span class="line">       foo = long_function_name(</span><br><span class="line">         var_one, var_two, var_three,</span><br><span class="line">         var_four)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># No hanging indent in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key:</span><br><span class="line">           long_dictionary_value,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3><span id="3-6-kong-xing-blank-lines">3.6 空行(Blank Lines)</span><a href="#3-6-kong-xing-blank-lines" class="header-anchor">#</a></h3><p>顶层的定义之间空两行， 方法定义之间空一行。</p><p>顶层定义之间空两行, 比如函数或者类定义。方法定义，类定义与第一个方法之间，都应该空一行。函数或方法中, 某些地方要是你觉得合适, 就空一行。</p><h3><span id="3-7-kong-ge-whitespace">3.7 空格(Whitespace)</span><a href="#3-7-kong-ge-whitespace" class="header-anchor">#</a></h3><p>按照标准的排版规范使用标点两边的空格。</p><p>括号内不要有空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: spam(ham[<span class="number">1</span>], &#123;eggs: <span class="number">2</span>&#125;, [])</span><br><span class="line">No:  spam( ham[ <span class="number">1</span> ], &#123; eggs: <span class="number">2</span> &#125;, [ ] )</span><br></pre></td></tr></table></figure><p>不要在逗号，分号，冒号前面加空格，在他们后面加。行尾不用加空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">if</span> x == <span class="number">4</span>:</span><br><span class="line">         print(x, y)</span><br><span class="line">     x, y = y, x</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">No:  <span class="keyword">if</span> x == <span class="number">4</span> :</span><br><span class="line">         print(x , y)</span><br><span class="line">     x , y = y , x</span><br></pre></td></tr></table></figure><p>参数列表，索引或切片的左括号前不应该加空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes: spam(<span class="number">1</span>)</span><br><span class="line">No:  spam (<span class="number">1</span>)</span><br><span class="line">Yes: dict[<span class="string">'key'</span>] = list[index]</span><br><span class="line">No:  dict [<span class="string">'key'</span>] = list [index]</span><br></pre></td></tr></table></figure><p>在切片中，应该添加适当的空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line">ham[<span class="number">1</span>:<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span>:<span class="number">3</span>], ham[:<span class="number">9</span>:<span class="number">3</span>], ham[<span class="number">1</span>::<span class="number">3</span>], ham[<span class="number">1</span>:<span class="number">9</span>:]</span><br><span class="line">ham[lower:upper], ham[lower:upper:], ham[lower::step]</span><br><span class="line">ham[lower+offset : upper+offset]</span><br><span class="line">ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]</span><br><span class="line">ham[lower + offset : upper + offset]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line">ham[lower + offset:upper + offset]</span><br><span class="line">ham[<span class="number">1</span>: <span class="number">9</span>], ham[<span class="number">1</span> :<span class="number">9</span>], ham[<span class="number">1</span>:<span class="number">9</span> :<span class="number">3</span>]</span><br><span class="line">ham[lower : : upper]</span><br><span class="line">ham[ : upper]</span><br></pre></td></tr></table></figure><p>在二元操作符两边都加上一个空格, 比如赋值(<code>=</code>)， 比较(<code>==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not</code>), 布尔(<code>and, or, not</code>)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: x == <span class="number">1</span></span><br><span class="line">No:  x&lt;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>当<code>=</code>用于指示关键字参数或默认参数值时，不要在其两侧使用空格。但是在进行类型注释的时候，允许使用空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag=<span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> Magic(r=real, i=imag)</span><br><span class="line">Yes: <span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag: float = <span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> Magic(r=real, i=imag)</span><br><span class="line"></span><br><span class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag = <span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> Magic(r = real, i = imag)</span><br><span class="line">No:  <span class="function"><span class="keyword">def</span> <span class="title">complex</span><span class="params">(real, imag: float=<span class="number">0.0</span>)</span>:</span> <span class="keyword">return</span> Magic(r = real, i = imag)</span><br></pre></td></tr></table></figure><p>不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于<code>:</code>，<code>#</code>，<code>=</code>等)，保持左对齐就可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line">  foo = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">  long_name = <span class="number">2</span>  <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">  dictionary = &#123;</span><br><span class="line">      <span class="string">'foo'</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">'long_name'</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line">  foo       = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">  long_name = <span class="number">2</span>     <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">  dictionary = &#123;</span><br><span class="line">      <span class="string">'foo'</span>      : <span class="number">1</span>,</span><br><span class="line">      <span class="string">'long_name'</span>: <span class="number">2</span>,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="3-8-shebang-xing-shebang-line">3.8 SheBang行(Shebang Line)</span><a href="#3-8-shebang-xing-shebang-line" class="header-anchor">#</a></h3><p>在计算领域中，Shebang(也称为 Hashbang )是一个由井号和叹号构成的字符序列 #! ，其出现在文本文件的第一行的前两个字符。 在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序载入器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数。</p><p>大部分.py文件不必以#!作为文件的开头。 根据 <a href="http://www.python.org/dev/peps/pep-0394/" target="_blank" rel="noopener">PEP-394</a> ，程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始。</p><h3><span id="3-9-zhu-shi-he-wen-dang-zi-fu-chuan-comments-and-docstrings">3.9 注释和文档字符串(Comments and Docstrings)</span><a href="#3-9-zhu-shi-he-wen-dang-zi-fu-chuan-comments-and-docstrings" class="header-anchor">#</a></h3><p>确保正确使用模块、函数、方法的文档字符串和行内注释。</p><h4><span id="3-9-1-wen-dang-zi-fu-chuan-docstrings">3.9.1 文档字符串(Docstrings)</span><a href="#3-9-1-wen-dang-zi-fu-chuan-docstrings" class="header-anchor">#</a></h4><blockquote><p>Python有一种独一无二的的注释方式：使用文档字符串。文档字符串是包，模块，类或函数里的第一个语句。这些字符串可以通过对象的<strong>doc</strong>成员被自动提取，并且被pydoc所用。 (你可以在你的模块上运行pydoc试一把， 看看它长什么样)。 我们对文档字符串的惯例是使用三重双引号”””( <a href="http://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP-257</a> )。 一个文档字符串应该这样组织：首先是一行以句号，问号或感叹号结尾的概述(或者该文档字符串单纯只有一行)。接着是一个空行。接着是文档字符串剩下的部分，它应该与文档字符串的第一行的第一个引号对齐。下面有更多文档字符串的格式化规范。</p></blockquote><h4><span id="3-9-2-mo-kuai-modules">3.9.2 模块(Modules)</span><a href="#3-9-2-mo-kuai-modules" class="header-anchor">#</a></h4><blockquote><p>每个文件应该包含一个许可证。根据项目使用的许可(例如：Apache 2.0，BSD，LGPL，GPL)，选择合适的许可证。</p></blockquote><h4><span id="3-9-3-han-shu-he-fang-fa-functions-and-methods">3.9.3 函数和方法(Functions and Methods)</span><a href="#3-9-3-han-shu-he-fang-fa-functions-and-methods" class="header-anchor">#</a></h4><blockquote><p>下文所指的函数，包括函数、方法以及生成器。</p><p>一个函数必须要有文档字符串，除非它满足以下条件：</p><ol><li>外部不可见</li><li>非常短小</li><li>简单明了</li></ol><p>文档字符串应该包含函数做什么，以及输入和输出的详细描述。通常，不应该描述”怎么做”，除非是一些复杂的算法。文档字符串应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了。对于复杂的代码，在代码旁边加注释会比使用文档字符串更有意义。</p><p>关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面如下文所述。每节应该以一个标题行开始。标题行以冒号结尾。除标题行外，节的其他内容应被缩进2个空格。</p><ul><li><p>Args:</p><p>列出每个参数的名字并在名字后使用一个冒号和一个空格，分隔对该参数的描述。如果描述太长超过了单行120字符，使用2或者4个空格的悬挂缩进(与文件其他部分保持一致)。描述应该包括所需的类型和含义。如果一个函数接受<em>foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出</em>foo和**bar。</p></li><li><p>Returns: (或者 Yields: 用于生成器)</p><p>描述返回值的类型和语义。如果函数返回None，这一部分可以省略。</p></li><li><p>Raises:</p><p>列出与接口有关的所有异常。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):</span><br><span class="line">&gt;     &quot;&quot;&quot;Fetches rows from a Bigtable.</span><br><span class="line">&gt; </span><br><span class="line">&gt;     Retrieves rows pertaining to the given keys from the Table instance</span><br><span class="line">&gt;     represented by big_table.  Silly things may happen if</span><br><span class="line">&gt;     other_silly_variable is not None.</span><br><span class="line">&gt; </span><br><span class="line">&gt;     Args:</span><br><span class="line">&gt;         big_table: An open Bigtable Table instance.</span><br><span class="line">&gt;         keys: A sequence of strings representing the key of each table row</span><br><span class="line">&gt;             to fetch.</span><br><span class="line">&gt;         other_silly_variable: Another optional variable, that has a much</span><br><span class="line">&gt;             longer name than the other args, and which does nothing.</span><br><span class="line">&gt; </span><br><span class="line">&gt;     Returns:</span><br><span class="line">&gt;         A dict mapping keys to the corresponding table row data</span><br><span class="line">&gt;         fetched. Each row is represented as a tuple of strings. For</span><br><span class="line">&gt;         example:</span><br><span class="line">&gt; </span><br><span class="line">&gt;         &#123;&apos;Serak&apos;: (&apos;Rigel VII&apos;, &apos;Preparer&apos;),</span><br><span class="line">&gt;          &apos;Zim&apos;: (&apos;Irk&apos;, &apos;Invader&apos;),</span><br><span class="line">&gt;          &apos;Lrrr&apos;: (&apos;Omicron Persei 8&apos;, &apos;Emperor&apos;)&#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;         If a key from the keys argument is missing from the dictionary,</span><br><span class="line">&gt;         then that row was not found in the table.</span><br><span class="line">&gt; </span><br><span class="line">&gt;     Raises:</span><br><span class="line">&gt;         IOError: An error occurred accessing the bigtable.Table object.</span><br><span class="line">&gt;     &quot;&quot;&quot;</span><br><span class="line">&gt;     pass</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4><span id="3-9-4-lei-classes">3.9.4 类(Classes)</span><a href="#3-9-4-lei-classes" class="header-anchor">#</a></h4><blockquote><p>类应该在其定义下有一个用于描述该类的文档字符串。如果你的类有公共属性(Attributes)，那么文档中应该有一个属性(Attributes)段。并且应该遵守和函数参数相同的格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; class SampleClass(object):</span><br><span class="line">&gt;     &quot;&quot;&quot;Summary of class here.</span><br><span class="line">&gt; </span><br><span class="line">&gt;     Longer class information....</span><br><span class="line">&gt;     Longer class information....</span><br><span class="line">&gt; </span><br><span class="line">&gt;     Attributes:</span><br><span class="line">&gt;         likes_spam: A boolean indicating if we like SPAM or not.</span><br><span class="line">&gt;         eggs: An integer count of the eggs we have laid.</span><br><span class="line">&gt;     &quot;&quot;&quot;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     def __init__(self, likes_spam=False):</span><br><span class="line">&gt;         &quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot;</span><br><span class="line">&gt;         self.likes_spam = likes_spam</span><br><span class="line">&gt;         self.eggs = 0</span><br><span class="line">&gt; </span><br><span class="line">&gt;     def public_method(self):</span><br><span class="line">&gt;         &quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4><span id="3-9-5-kuai-zhu-shi-he-xing-zhu-shi-block-and-inline-comments">3.9.5 块注释和行注释(Block and Inline Comments)</span><a href="#3-9-5-kuai-zhu-shi-he-xing-zhu-shi-block-and-inline-comments" class="header-anchor">#</a></h4><blockquote><p>最需要写注释的是代码中那些技巧性的部分。如果你在下次 <a href="http://en.wikipedia.org/wiki/Code_review" target="_blank" rel="noopener">代码审查</a> 的时候必须解释一下，那么你应该现在就给它写注释。对于复杂的操作，应该在其操作开始前写上若干行注释。对于不是一目了然的代码，应在其行尾添加注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; # We use a weighted dictionary search to find out where i is in</span><br><span class="line">&gt; # the array.  We extrapolate position based on the largest num</span><br><span class="line">&gt; # in the array and the array size and then do binary search to</span><br><span class="line">&gt; # get the exact number.</span><br><span class="line">&gt; </span><br><span class="line">&gt; if i &amp; (i-1) == 0:        # true iff i is a power of 2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>为了提高可读性，注释应该至少离开代码2个空格。</p><p>另一方面，绝不要描述代码。 假设阅读代码的人比你更懂Python， 他只是不知道你的代码要做什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; # BAD COMMENT: Now go through the b array and make sure whenever i occurs</span><br><span class="line">&gt; # the next element is i+1</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4><span id="3-9-6-biao-dian-fu-he-pin-xie-he-yu-fa-punctuation-spelling-and-grammar">3.9.6 标点符合、拼写和语法(Punctuation, Spelling and Grammar)</span><a href="#3-9-6-biao-dian-fu-he-pin-xie-he-yu-fa-punctuation-spelling-and-grammar" class="header-anchor">#</a></h4><p>大家都喜欢读一份写得很优雅的注释，而不是杂乱没有头绪的注释。注释应该是一段通顺的语句。完整的句子比一个片段可读性更强。</p><p>源代码保持高度的清晰度和可读性是非常重要的。适当的标点符号、词汇选择和语法是必要的。</p><h3><span id="3-10-lei-classes">3.10 类(Classes)</span><a href="#3-10-lei-classes" class="header-anchor">#</a></h3><p>Python3起，默认的类都继承自<code>object</code>，不用再显式继承<code>object</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Okay: <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3><span id="3-11-zi-fu-chuan-strings">3.11 字符串(Strings)</span><a href="#3-11-zi-fu-chuan-strings" class="header-anchor">#</a></h3><p>使用%操作符或者格式化方法<code>format</code>格式化字符串。Python3.6提供了f-string ，参考<a href="https://www.python.org/dev/peps/pep-0498/" target="_blank" rel="noopener">PEP-498</a>。简单的情况使用<code>+</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Yes: x = a + b</span><br><span class="line">     x = <span class="string">'%s, %s!'</span> % (imperative, expletive)</span><br><span class="line">     x = <span class="string">'&#123;&#125;, &#123;&#125;'</span>.format(first, second)</span><br><span class="line">     x = <span class="string">'name: %s; score: %d'</span> % (name, n)</span><br><span class="line">     x = <span class="string">'name: &#123;&#125;; score: &#123;&#125;'</span>.format(name, n)</span><br><span class="line">     x = <span class="string">f'name: <span class="subst">&#123;name&#125;</span>; score: <span class="subst">&#123;n&#125;</span>'</span>  <span class="comment"># Python 3.6+</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">No: x = <span class="string">'%s%s'</span> % (a, b)  <span class="comment"># use + in this case</span></span><br><span class="line">    x = <span class="string">'&#123;&#125;&#123;&#125;'</span>.format(a, b)  <span class="comment"># use + in this case</span></span><br><span class="line">    x = first + <span class="string">', '</span> + second</span><br><span class="line">    x = <span class="string">'name: '</span> + name + <span class="string">'; score: '</span> + str(n)</span><br></pre></td></tr></table></figure><p>避免在循环中用<code>+</code>和<code>+=</code>操作符来累加字符串。 由于字符串是不可变的，这样做会创建不必要的临时对象，并且导致二次方而不是线性的运行时间。作为替代方案，你可以将每个子串加入列表，然后在循环结束后用 <code>.join</code> 连接列表。 (也可以将每个子串写入一个 <code>cStringIO.StringIO</code> 缓存中。)</p><p>虽然Cpython对<code>+</code>和<code>+=</code>进行了优化，速度比<code>join</code>还快，但是不建议依赖特定的解释器进行编程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes: items = [<span class="string">'&lt;table&gt;'</span>]</span><br><span class="line">     <span class="keyword">for</span> last_name, first_name <span class="keyword">in</span> employee_list:</span><br><span class="line">         items.append(<span class="string">'&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;'</span> % (last_name, first_name))</span><br><span class="line">     items.append(<span class="string">'&lt;/table&gt;'</span>)</span><br><span class="line">     employee_table = <span class="string">''</span>.join(items)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">No: employee_table = <span class="string">'&lt;table&gt;'</span></span><br><span class="line">    <span class="keyword">for</span> last_name, first_name <span class="keyword">in</span> employee_list:</span><br><span class="line">        employee_table += <span class="string">'&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;'</span> % (last_name, first_name)</span><br><span class="line">    employee_table += <span class="string">'&lt;/table&gt;'</span></span><br></pre></td></tr></table></figure><p>在同一个文件中， 保持使用字符串引号的一致性。要么都是双引号，要么都是单引号， 在遇见字符串中有引号时，使用另一种引号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line">     Python(<span class="string">'Why are you hiding your eyes?'</span>)</span><br><span class="line">     Gollum(<span class="string">"I'm scared of lint errors."</span>)</span><br><span class="line">     Narrator(<span class="string">'"Good!" thought a happy Python reviewer.'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line">     Python(<span class="string">"Why are you hiding your eyes?"</span>)</span><br><span class="line">     Gollum(<span class="string">'The lint. It burns. It burns us.'</span>)</span><br><span class="line">     Gollum(<span class="string">"Always the great lint. Watching. Watching."</span>)</span><br></pre></td></tr></table></figure><p>为多行字符串使用三重双引号”””而非三重单引号’’’。多行字符串与程序其他部分的缩进方式不一致， 使用隐式行链接来替代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line">print(<span class="string">"This is much nicer.\n"</span></span><br><span class="line">      <span class="string">"Do it this way.\n"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  No:</span><br><span class="line">    print(<span class="string">"""This is pretty ugly.</span></span><br><span class="line"><span class="string">Don't do this.</span></span><br><span class="line"><span class="string">"""</span>)</span><br></pre></td></tr></table></figure><h3><span id="3-12-wen-jian-he-sockets-files-and-sockets">3.12 文件和sockets(Files and Sockets)</span><a href="#3-12-wen-jian-he-sockets-files-and-sockets" class="header-anchor">#</a></h3><p>在文件和sockets结束时，显式的关闭它。</p><p>除文件外，sockets或其他类似文件的对象在没有必要的情况下打开，会有许多副作用，例如：</p><ol><li>它们可能会消耗有限的系统资源，如文件描述符。如果这些资源在使用后没有及时归还系统，那么用于处理这些对象的代码会将资源消耗殆尽。</li><li>持有文件将会阻止对于文件的其他诸如移动、删除之类的操作。</li><li>仅仅是从逻辑上关闭文件和sockets，那么它们仍然可能会被其共享的程序在无意中进行读或者写操作。 只有当它们真正被关闭后，对于它们尝试进行读或者写操作将会抛出异常，并使得问题快速显现出来。</li></ol><p>而且，对文件对象析构时，文件和sockets会自动关闭。</p><ol><li>不同的Python解释器实现了不同的gc。</li><li>对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等).</li></ol><p>推荐使用<code>with</code>管理文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"hello.txt"</span>) <span class="keyword">as</span> hello_file:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> hello_file:</span><br><span class="line">        <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure><p>对于不支持<code>with</code>的类文件对象，使用<code>contextlib.closing()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> contextlib.closing(urllib.urlopen(<span class="string">"http://www.python.org/"</span>)) <span class="keyword">as</span> front_page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> front_page:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><h3><span id="3-13-todo-zhu-shi-todo-comments">3.13 TODO注释(TODO  Comments)</span><a href="#3-13-todo-zhu-shi-todo-comments" class="header-anchor">#</a></h3><p>为临时代码使用TODO注释，它是一种短期解决方案。</p><p>TODO注释应该在所有开头处包含”TODO”字符串，紧跟着是用括号括起来的你的名字、email地址或其它标识符。然后是一个可选的冒号，接着必须有一行注释， 解释要做什么。</p><p>主要目的是为了有一个统一的TODO格式， 这样添加注释的人就可以搜索到他的注释。</p><p>写了TODO注释并不保证写的人会亲自解决问题。当你写了一个TODO，请注上你的名字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TODO(kl@gmail.com): Use a "*" here for string repetition.</span></span><br><span class="line"><span class="comment"># TODO(Zeke) Change this to use relations.</span></span><br></pre></td></tr></table></figure><h3><span id="3-14-dao-ru-ge-shi-hua-imports-formatting">3.14 导入格式化(Imports formatting)</span><a href="#3-14-dao-ru-ge-shi-hua-imports-formatting" class="header-anchor">#</a></h3><p>导入需要独占一行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">import</span> os</span><br><span class="line">     <span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No:  <span class="keyword">import</span> os, sys</span><br></pre></td></tr></table></figure><p>导入总应该放在文件顶部，位于模块注释和文档字符串之后，模块全局变量和常量之前。导入应该按照以下顺序分组:</p><ol><li>标准库导入，比如：<code>import sys</code></li><li>第三方库导入，比如：<code>import tensorflow as tf</code></li><li>应用程序指定导入，比如：<code>from otherproject.ai import mind</code></li></ol><p>导入的每一部分需要按字典序排序，忽略大小写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argcomplete</span><br><span class="line"><span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> cryptography</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> otherproject.ai <span class="keyword">import</span> body</span><br><span class="line"><span class="keyword">from</span> otherproject.ai <span class="keyword">import</span> mind</span><br><span class="line"><span class="keyword">from</span> otherproject.ai <span class="keyword">import</span> soul</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> myproject.backend.hgwells <span class="keyword">import</span> time_machine</span><br><span class="line"><span class="keyword">from</span> myproject.backend.state_machine <span class="keyword">import</span> main_loop</span><br></pre></td></tr></table></figure><h3><span id="3-15-yu-ju-statements">3.15 语句(Statements)</span><a href="#3-15-yu-ju-statements" class="header-anchor">#</a></h3><p>通常每个语句独占一行。</p><p>不过， 如果仅仅只有if语句，可以把整个语句放在一行。 如果为了测试，临时这么做也是可以的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> foo: bar(foo)</span><br><span class="line">  <span class="keyword">import</span> pdb; pdb.set_trace()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> foo: bar(foo)</span><br><span class="line">  <span class="keyword">else</span>:   baz(foo)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:               bar(foo)</span><br><span class="line">  <span class="keyword">except</span> ValueError: baz(foo)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      bar(foo)</span><br><span class="line">  <span class="keyword">except</span> ValueError: baz(foo)</span><br></pre></td></tr></table></figure><h3><span id="3-16-fang-wen-kong-zhi-access-control">3.16 访问控制(Access Control)</span><a href="#3-16-fang-wen-kong-zhi-access-control" class="header-anchor">#</a></h3><p>使用<code>@property</code>对属性进行控制，不要另外写<code>getter</code>和<code>setter</code>方法。</p><p>例外：如果逻辑非常复杂，或者调用非常频繁影响到性能，那么可以使用函数调用，需要遵守命名规则比如<code>set_foo()</code> <code>get_foo()</code>。</p><h3><span id="3-17-ming-ming-naming">3.17 命名(Naming)</span><a href="#3-17-ming-ming-naming" class="header-anchor">#</a></h3><p>Python命名分为许多种类：</p><p><code>module_name</code>, <code>package_name</code>, <code>ClassName</code>, <code>method_name</code>, <code>ExceptionName</code>, <code>function_name</code>, <code>GLOBAL_CONSTANT_NAME</code>,<code>global_var_name</code>, <code>instance_var_name</code>, <code>function_parameter_name</code>, <code>local_var_name</code>。</p><h4><span id="3-17-1-ying-gai-bi-mian-de-ming-cheng">3.17.1应该避免的名称</span><a href="#3-17-1-ying-gai-bi-mian-de-ming-cheng" class="header-anchor">#</a></h4><blockquote><ol><li>单字符名称， 除了计数器和迭代器。</li><li>包/模块名中的连字符(-)。</li><li>双下划线开头并结尾的名称(除了Python保留的例如<strong>init</strong>)。</li></ol></blockquote><h4><span id="3-17-2-ming-ming-yue-ding">3.17.2 命名约定</span><a href="#3-17-2-ming-ming-yue-ding" class="header-anchor">#</a></h4><blockquote><ol><li>所谓”内部(Internal)”表示仅模块内可用，或者，在类内是保护或私有的。</li><li>用单下划线(_)开头表示模块变量或函数是protected的(使用import * from时不会包含)。</li><li>用双下划线(__)开头的实例变量或方法表示类内私有。</li><li>将相关的类和顶层函数放在同一个模块里。不像Java，没必要限制一个类一个模块。</li><li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格)，但是模块名应该用小写加下划线的方式(如lower_with_under.py)。尽管已经有很多现存的模块使用类似于CapWords.py这样的命名，但现在已经不鼓励这样做，因为如果模块名碰巧和类名一致，这会让人困扰。</li></ol></blockquote><h4><span id="3-17-3-wen-jian-ming-ming">3.17.3 文件命名</span><a href="#3-17-3-wen-jian-ming-ming" class="header-anchor">#</a></h4><p>Python文件名必须是<code>.py</code>的扩展名，不能包含连字符(<code>-</code>)。因此这些文件可以被导入和单元测试。如果你想要一个没有扩展名的可执行文件，使用软链接或者是一个bash来包装 <code>exec &quot;$0.py&quot; &quot;$@&quot;</code>。</p><h4><span id="3-17-4-guido-van-rossum-tui-jian-de-ming-ming-gui-fan">3.17.4 Guido van Rossum推荐的命名规范</span><a href="#3-17-4-guido-van-rossum-tui-jian-de-ming-ming-gui-fan" class="header-anchor">#</a></h4><table><thead><tr><th>类型(Type)</th><th>公共(Public)</th><th>内部(Internal)</th></tr></thead><tbody><tr><td>Packages</td><td><code>lower_with_under</code></td><td></td></tr><tr><td>Modules</td><td><code>lower_with_under</code></td><td><code>_lower_with_under</code></td></tr><tr><td>Classes</td><td><code>CapWords</code></td><td><code>_CapWords</code></td></tr><tr><td>Exceptions</td><td><code>CapWords</code></td><td></td></tr><tr><td>Functions</td><td><code>lower_with_under()</code></td><td><code>_lower_with_under()</code></td></tr><tr><td>Global/Class Constants</td><td><code>CAPS_WITH_UNDER</code></td><td><code>_CAPS_WITH_UNDER</code></td></tr><tr><td>Global/Class Variables</td><td><code>lower_with_under</code></td><td><code>_lower_with_under</code></td></tr><tr><td>Instance Variables</td><td><code>lower_with_under</code></td><td><code>_lower_with_under</code> (protected)</td></tr><tr><td>Method Names</td><td><code>lower_with_under()</code></td><td><code>_lower_with_under()</code> (protected)</td></tr><tr><td>Function/Method Parameters</td><td><code>lower_with_under</code></td><td></td></tr><tr><td>Local Variables</td><td><code>lower_with_under</code></td></tr></tbody></table><p>Python 通过双下划线命名来支持私有变量。但是最好使用单下划线来作为内部变量访问。</p><h3><span id="3-18-zhu-han-shu-main">3.18 主函数(Main)</span><a href="#3-18-zhu-han-shu-main" class="header-anchor">#</a></h3><p>每一个可执行脚本都应该能被导入，并且导入不会执行这个脚本的主要功能部分。 主要功能部分应该被放在主函数中。</p><p>代码在执行主程序前应该检查<code>if __name__ == &#39;__main__&#39;</code>，这样当模块被导入时，这部分代码就不会被执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>所有的顶层代码在模块导入时都会被执行。因此要小心在全局中调用函数，创建对象的操作，需要测试的代码写在<code>if __name__ == &#39;__main__&#39;</code>下面。</p><h3><span id="3-19-han-shu-chang-du-function-length">3.19 函数长度(Function length)</span><a href="#3-19-han-shu-chang-du-function-length" class="header-anchor">#</a></h3><p>推荐使用小而精的函数。</p><p>有时候一段比较长的函数是比较合适的，所以这里不会过多地限制函数的长度。如果一个函数超过40行，那么要考虑一下它是否能被合理地拆分。一个很长的函数可能在这个需求下是适用的，并且没有bug，但是如果新增了需求需要对它进行改动，在多次改动后可能会导致难以找到的bug。函数应该是简洁明了，易于他人维护的。</p><p>如果你正好遇到一个函数代码量非常地长并且复杂，那么最好先把它拆分为多个函数易于管理。不要觉得拆分是一件很困难的事情，为了你的长远考虑，我建议你这么做。</p><h3><span id="3-20-lei-xing-zhu-shi-type-annotations">3.20 类型注释(Type Annotations)</span><a href="#3-20-lei-xing-zhu-shi-type-annotations" class="header-anchor">#</a></h3><h4><span id="3-20-1-yi-ban-gui-ze">3.20.1 一般规则</span><a href="#3-20-1-yi-ban-gui-ze" class="header-anchor">#</a></h4><ul><li>了解<a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener">PEP-484</a>。</li><li>不要在方法中注释<code>self</code>和<code>cls</code>。</li><li>如果变量或返回值不明确，使用<code>Any</code>。</li><li>不要求注释所有的函数。<ul><li>至少注释公共API。</li><li>在明确和灵活之间做一个平衡。</li><li>注释的代码相对难理解。</li><li>注释代码是一个稳妥的做法，对一段成熟的代码一定要进行注释。</li><li>注释代码可以发现类型相关的错误。</li></ul></li></ul><h2><span id="5-lin-bie-zeng-yan">5 临别赠言</span><a href="#5-lin-bie-zeng-yan" class="header-anchor">#</a></h2><p><code>务必保持代码的一致性</code></p><p>如果你正在编辑代码，花几分钟看一下周边代码，然后决定风格。如果它们在所有的算术操作符两边都使用空格，那么你也应该这样做，如果它们的注释都用标记包围起来，那么你的注释也要这样。</p><p>制定风格指南的目的在于让代码有规可循，这样人们就可以专注于”你在说什么”，而不是”你在怎么说”。我们在这里给出的是全局的规范，但是本地的规范同样重要。如果你加到一个文件里的代码和原有代码大相径庭，它会让读者不知所措，请避免这种情况。</p><p>作者：倪侃（<a href="mailto:859905874@qq.com" target="_blank" rel="noopener">859905874@qq.com</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python编程规范&quot;&gt;&lt;a href=&quot;#Python编程规范&quot; class=&quot;headerlink&quot; title=&quot;Python编程规范&quot;&gt;&lt;/a&gt;Python编程规范&lt;/h1&gt;&lt;div class=&quot;tocStart&quot;&gt;&lt;/div&gt;

&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-bei-jing&quot;&gt;1 背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-yu-yan-gui-fan&quot;&gt;2 语言规范&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#2-1-dai-ma-jian-cha-gong-ju&quot;&gt;2.1 代码检查工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-2-dao-ru-imports&quot;&gt;2.2 导入(Imports)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-3-bao-packages&quot;&gt;2.3 包(Packages)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-4-yi-chang-exceptions&quot;&gt;2.4 异常(Exceptions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-5-quan-ju-bian-liang-global-variables&quot;&gt;2.5 全局变量(Global variables)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-6-qian-tao-ju-bu-nei-bu-lei-he-han-shu-nested-local-inner-classes-and-functions&quot;&gt;2.6 嵌套、局部、内部类和函数(Nested/Local/Inner Classes and Functions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-7-tui-dao-shi-he-sheng-cheng-qi-biao-da-shi-comprehensions-generator-expressions&quot;&gt;2.7 推导式和生成器表达式(Comprehensions &amp;amp; Generator Expressions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-8-mo-ren-die-dai-qi-he-cao-zuo-fu-default-iterators-and-operators&quot;&gt;2.8 默认迭代器和操作符(Default Iterators and Operators)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-9-sheng-cheng-qi-generators&quot;&gt;2.9 生成器(Generators)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-10-ni-ming-han-shu-lambda-functions&quot;&gt;2.10 匿名函数(Lambda Functions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-11-tiao-jian-biao-da-shi-conditional-expressions&quot;&gt;2.11 条件表达式(Conditional Expressions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-12-mo-ren-can-shu-zhi-default-argument-values&quot;&gt;2.12 默认参数值(Default Argument Values)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-13-shu-xing-properties&quot;&gt;2.13 属性(Properties)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-14-true-false-de-qiu-zhi-true-false-evaluations&quot;&gt;2.14 True/False的求值(True/False evaluations)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-15-guo-shi-de-yu-yan-te-xing-deprecated-language-features&quot;&gt;2.15 过时的语言特性(Deprecated Language Features)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-16-bian-liang-zuo-yong-yu-lexical-scoping&quot;&gt;2.16 变量作用域(Lexical Scoping)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-17-han-shu-he-fang-fa-zhuang-shi-qi-function-and-method-decorators&quot;&gt;2.17 函数和方法装饰器(Function and Method Decorators)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-18-xian-cheng-threading&quot;&gt;2.18 线程(Threading)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-19-qiang-da-de-te-xing-power-features&quot;&gt;2.19 强大的特性(Power Features)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-20-xian-dai-hua-python-modern-python-python-3-and-from-future-imports&quot;&gt;2.20 现代化Python(Modern Python: Python 3 and from __future__ imports)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-21-dai-ma-lei-xing-zhu-shi-type-annotated-code&quot;&gt;2.21 代码类型注释(Type Annotated Code)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-python-feng-ge-gui-fan&quot;&gt;3 Python风格规范&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#3-1-dai-ma-ge-shi-hua-gong-ju&quot;&gt;3.1 代码格式化工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-2-fen-hao-semicolons&quot;&gt;3.2 分号(Semicolons)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-3-xing-chang-du-line-length&quot;&gt;3.3 行长度(Line length)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-4-gua-hao-parentheses&quot;&gt;3.4 括号(Parentheses)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-5-suo-jin-indentation&quot;&gt;3.5 缩进(Indentation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-6-kong-xing-blank-lines&quot;&gt;3.6 空行(Blank Lines)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-7-kong-ge-whitespace&quot;&gt;3.7 空格(Whitespace)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-8-shebang-xing-shebang-line&quot;&gt;3.8 SheBang行(Shebang Line)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-9-zhu-shi-he-wen-dang-zi-fu-chuan-comments-and-docstrings&quot;&gt;3.9 注释和文档字符串(Comments and Docstrings)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-10-lei-classes&quot;&gt;3.10 类(Classes)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-11-zi-fu-chuan-strings&quot;&gt;3.11 字符串(Strings)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-12-wen-jian-he-sockets-files-and-sockets&quot;&gt;3.12 文件和sockets(Files and Sockets)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-13-todo-zhu-shi-todo-comments&quot;&gt;3.13 TODO注释(TODO  Comments)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-14-dao-ru-ge-shi-hua-imports-formatting&quot;&gt;3.14 导入格式化(Imports formatting)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-15-yu-ju-statements&quot;&gt;3.15 语句(Statements)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-16-fang-wen-kong-zhi-access-control&quot;&gt;3.16 访问控制(Access Control)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-17-ming-ming-naming&quot;&gt;3.17 命名(Naming)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-18-zhu-han-shu-main&quot;&gt;3.18 主函数(Main)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-19-han-shu-chang-du-function-length&quot;&gt;3.19 函数长度(Function length)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-20-lei-xing-zhu-shi-type-annotations&quot;&gt;3.20 类型注释(Type Annotations)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-lin-bie-zeng-yan&quot;&gt;5 临别赠言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;div class=&quot;tocEnd&quot;&gt;&lt;/div&gt;

&lt;h2 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1 背景&quot;&gt;&lt;/a&gt;1 背景&lt;/h2&gt;&lt;p&gt;​        Python是一门动态语言。Python有着非常自由的语法和非常多的特性，开发者可以写出各种充满社会特色主义的代码。本规范的目的不是为了约束开发者的创造力和生产力，而是为了限制开发者的过度个性化，统一团队的代码风格，通过风格一致的代码来更好地进行团队成员之间的协作开发。本规范适用Python3.5以上的版本，部分规范在Python2.7不一定适用。本规范也不推荐开发者继续使用Python2.7开发，Python3会不断地加入新的特性，而Python2.7 到2020年1月1日后将停止被维护。本规范将辅助开发者写出简洁、优雅、高效和风格一致的代码，并且减少踩坑的概率，提升代码的质量，增强开发者的编程规范意识。&lt;/p&gt;
&lt;p&gt;​        本规范主要参照&lt;a href=&quot;https://github.com/google/styleguide/blob/gh-pages/pyguide.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;google code style&lt;/a&gt;和 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PEP-8&lt;/a&gt;完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="codestyle python" scheme="http://yoursite.com/tags/codestyle-python/"/>
    
  </entry>
  
  <entry>
    <title>简历</title>
    <link href="http://yoursite.com/2018/07/29/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    <id>http://yoursite.com/2018/07/29/关于我/</id>
    <published>2018-07-29T04:57:40.000Z</published>
    <updated>2019-01-29T17:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="ji-ben-xin-xi">基本信息</span><a href="#ji-ben-xin-xi" class="header-anchor">#</a></h2><p>​    Github: <a href="https://github.com/nikan1996" target="_blank" rel="noopener">https://github.com/nikan1996</a></p><p>​    Email: <a href="mailto:859905874@qq.com" target="_blank" rel="noopener">859905874@qq.com</a></p><a id="more"></a><h2><span id="jiao-yu-jing-li">教育经历</span><a href="#jiao-yu-jing-li" class="header-anchor">#</a></h2><p>​    2014年9月-2018年7月本科毕业于浙江工业大学。</p><h2><span id="shi-xi-jing-li">实习经历</span><a href="#shi-xi-jing-li" class="header-anchor">#</a></h2><ul><li><p>2017年3月-2017年9月 <a href="http://www.dtdream.com/" target="_blank" rel="noopener">数梦工场</a>，职位：后台开发工程师。</p></li><li><p>2017年10月-2018年6月 <a href="https://www.eigentech.ai/en/" target="_blank" rel="noopener">艾耕科技</a>，职位：爬虫开发工程师。</p></li></ul><h2><span id="gong-zuo-jing-li">工作经历</span><a href="#gong-zuo-jing-li" class="header-anchor">#</a></h2><ul><li>2018年7月-2019年1月 <a href="https://www.eigentech.ai/en/" target="_blank" rel="noopener">艾耕科技</a>， 职位：数据平台开发工程师。</li></ul><h2><span id="xing-qu-ai-hao">兴趣爱好</span><a href="#xing-qu-ai-hao" class="header-anchor">#</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h2&gt;&lt;p&gt;​    Github: &lt;a href=&quot;https://github.com/nikan1996&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/nikan1996&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​    Email: &lt;a href=&quot;mailto:859905874@qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;859905874@qq.com&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="resume" scheme="http://yoursite.com/tags/resume/"/>
    
  </entry>
  
</feed>
